// Code generated by protoc-gen-connect-go. DO NOT EDIT.
//
// Source: api/v1/api.proto

package v1connect

import (
	context "context"
	errors "errors"
	connect_go "github.com/bufbuild/connect-go"
	v1 "github.com/ts1106/favomic-api/gen/api/v1"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	http "net/http"
	strings "strings"
)

// This is a compile-time assertion to ensure that this generated file and the connect package are
// compatible. If you get a compiler error that this constant is not defined, this code was
// generated with a version of connect newer than the one compiled into your binary. You can fix the
// problem by either regenerating this code with an older version of connect or updating the connect
// version compiled into your binary.
const _ = connect_go.IsAtLeastVersion0_1_0

const (
	// AuthorServiceName is the fully-qualified name of the AuthorService service.
	AuthorServiceName = "api.AuthorService"
	// ComicServiceName is the fully-qualified name of the ComicService service.
	ComicServiceName = "api.ComicService"
	// EpisodeServiceName is the fully-qualified name of the EpisodeService service.
	EpisodeServiceName = "api.EpisodeService"
	// MagazineServiceName is the fully-qualified name of the MagazineService service.
	MagazineServiceName = "api.MagazineService"
	// TagServiceName is the fully-qualified name of the TagService service.
	TagServiceName = "api.TagService"
)

// AuthorServiceClient is a client for the api.AuthorService service.
type AuthorServiceClient interface {
	Create(context.Context, *connect_go.Request[v1.CreateAuthorRequest]) (*connect_go.Response[v1.Author], error)
	Get(context.Context, *connect_go.Request[v1.GetAuthorRequest]) (*connect_go.Response[v1.Author], error)
	Update(context.Context, *connect_go.Request[v1.UpdateAuthorRequest]) (*connect_go.Response[v1.Author], error)
	Delete(context.Context, *connect_go.Request[v1.DeleteAuthorRequest]) (*connect_go.Response[emptypb.Empty], error)
	List(context.Context, *connect_go.Request[v1.ListAuthorRequest]) (*connect_go.Response[v1.ListAuthorResponse], error)
	BatchCreate(context.Context, *connect_go.Request[v1.BatchCreateAuthorsRequest]) (*connect_go.Response[v1.BatchCreateAuthorsResponse], error)
	Search(context.Context, *connect_go.Request[v1.SearchAuthorRequest]) (*connect_go.Response[v1.Author], error)
}

// NewAuthorServiceClient constructs a client for the api.AuthorService service. By default, it uses
// the Connect protocol with the binary Protobuf Codec, asks for gzipped responses, and sends
// uncompressed requests. To use the gRPC or gRPC-Web protocols, supply the connect.WithGRPC() or
// connect.WithGRPCWeb() options.
//
// The URL supplied here should be the base URL for the Connect or gRPC server (for example,
// http://api.acme.com or https://acme.com/grpc).
func NewAuthorServiceClient(httpClient connect_go.HTTPClient, baseURL string, opts ...connect_go.ClientOption) AuthorServiceClient {
	baseURL = strings.TrimRight(baseURL, "/")
	return &authorServiceClient{
		create: connect_go.NewClient[v1.CreateAuthorRequest, v1.Author](
			httpClient,
			baseURL+"/api.AuthorService/Create",
			opts...,
		),
		get: connect_go.NewClient[v1.GetAuthorRequest, v1.Author](
			httpClient,
			baseURL+"/api.AuthorService/Get",
			opts...,
		),
		update: connect_go.NewClient[v1.UpdateAuthorRequest, v1.Author](
			httpClient,
			baseURL+"/api.AuthorService/Update",
			opts...,
		),
		delete: connect_go.NewClient[v1.DeleteAuthorRequest, emptypb.Empty](
			httpClient,
			baseURL+"/api.AuthorService/Delete",
			opts...,
		),
		list: connect_go.NewClient[v1.ListAuthorRequest, v1.ListAuthorResponse](
			httpClient,
			baseURL+"/api.AuthorService/List",
			opts...,
		),
		batchCreate: connect_go.NewClient[v1.BatchCreateAuthorsRequest, v1.BatchCreateAuthorsResponse](
			httpClient,
			baseURL+"/api.AuthorService/BatchCreate",
			opts...,
		),
		search: connect_go.NewClient[v1.SearchAuthorRequest, v1.Author](
			httpClient,
			baseURL+"/api.AuthorService/Search",
			opts...,
		),
	}
}

// authorServiceClient implements AuthorServiceClient.
type authorServiceClient struct {
	create      *connect_go.Client[v1.CreateAuthorRequest, v1.Author]
	get         *connect_go.Client[v1.GetAuthorRequest, v1.Author]
	update      *connect_go.Client[v1.UpdateAuthorRequest, v1.Author]
	delete      *connect_go.Client[v1.DeleteAuthorRequest, emptypb.Empty]
	list        *connect_go.Client[v1.ListAuthorRequest, v1.ListAuthorResponse]
	batchCreate *connect_go.Client[v1.BatchCreateAuthorsRequest, v1.BatchCreateAuthorsResponse]
	search      *connect_go.Client[v1.SearchAuthorRequest, v1.Author]
}

// Create calls api.AuthorService.Create.
func (c *authorServiceClient) Create(ctx context.Context, req *connect_go.Request[v1.CreateAuthorRequest]) (*connect_go.Response[v1.Author], error) {
	return c.create.CallUnary(ctx, req)
}

// Get calls api.AuthorService.Get.
func (c *authorServiceClient) Get(ctx context.Context, req *connect_go.Request[v1.GetAuthorRequest]) (*connect_go.Response[v1.Author], error) {
	return c.get.CallUnary(ctx, req)
}

// Update calls api.AuthorService.Update.
func (c *authorServiceClient) Update(ctx context.Context, req *connect_go.Request[v1.UpdateAuthorRequest]) (*connect_go.Response[v1.Author], error) {
	return c.update.CallUnary(ctx, req)
}

// Delete calls api.AuthorService.Delete.
func (c *authorServiceClient) Delete(ctx context.Context, req *connect_go.Request[v1.DeleteAuthorRequest]) (*connect_go.Response[emptypb.Empty], error) {
	return c.delete.CallUnary(ctx, req)
}

// List calls api.AuthorService.List.
func (c *authorServiceClient) List(ctx context.Context, req *connect_go.Request[v1.ListAuthorRequest]) (*connect_go.Response[v1.ListAuthorResponse], error) {
	return c.list.CallUnary(ctx, req)
}

// BatchCreate calls api.AuthorService.BatchCreate.
func (c *authorServiceClient) BatchCreate(ctx context.Context, req *connect_go.Request[v1.BatchCreateAuthorsRequest]) (*connect_go.Response[v1.BatchCreateAuthorsResponse], error) {
	return c.batchCreate.CallUnary(ctx, req)
}

// Search calls api.AuthorService.Search.
func (c *authorServiceClient) Search(ctx context.Context, req *connect_go.Request[v1.SearchAuthorRequest]) (*connect_go.Response[v1.Author], error) {
	return c.search.CallUnary(ctx, req)
}

// AuthorServiceHandler is an implementation of the api.AuthorService service.
type AuthorServiceHandler interface {
	Create(context.Context, *connect_go.Request[v1.CreateAuthorRequest]) (*connect_go.Response[v1.Author], error)
	Get(context.Context, *connect_go.Request[v1.GetAuthorRequest]) (*connect_go.Response[v1.Author], error)
	Update(context.Context, *connect_go.Request[v1.UpdateAuthorRequest]) (*connect_go.Response[v1.Author], error)
	Delete(context.Context, *connect_go.Request[v1.DeleteAuthorRequest]) (*connect_go.Response[emptypb.Empty], error)
	List(context.Context, *connect_go.Request[v1.ListAuthorRequest]) (*connect_go.Response[v1.ListAuthorResponse], error)
	BatchCreate(context.Context, *connect_go.Request[v1.BatchCreateAuthorsRequest]) (*connect_go.Response[v1.BatchCreateAuthorsResponse], error)
	Search(context.Context, *connect_go.Request[v1.SearchAuthorRequest]) (*connect_go.Response[v1.Author], error)
}

// NewAuthorServiceHandler builds an HTTP handler from the service implementation. It returns the
// path on which to mount the handler and the handler itself.
//
// By default, handlers support the Connect, gRPC, and gRPC-Web protocols with the binary Protobuf
// and JSON codecs. They also support gzip compression.
func NewAuthorServiceHandler(svc AuthorServiceHandler, opts ...connect_go.HandlerOption) (string, http.Handler) {
	mux := http.NewServeMux()
	mux.Handle("/api.AuthorService/Create", connect_go.NewUnaryHandler(
		"/api.AuthorService/Create",
		svc.Create,
		opts...,
	))
	mux.Handle("/api.AuthorService/Get", connect_go.NewUnaryHandler(
		"/api.AuthorService/Get",
		svc.Get,
		opts...,
	))
	mux.Handle("/api.AuthorService/Update", connect_go.NewUnaryHandler(
		"/api.AuthorService/Update",
		svc.Update,
		opts...,
	))
	mux.Handle("/api.AuthorService/Delete", connect_go.NewUnaryHandler(
		"/api.AuthorService/Delete",
		svc.Delete,
		opts...,
	))
	mux.Handle("/api.AuthorService/List", connect_go.NewUnaryHandler(
		"/api.AuthorService/List",
		svc.List,
		opts...,
	))
	mux.Handle("/api.AuthorService/BatchCreate", connect_go.NewUnaryHandler(
		"/api.AuthorService/BatchCreate",
		svc.BatchCreate,
		opts...,
	))
	mux.Handle("/api.AuthorService/Search", connect_go.NewUnaryHandler(
		"/api.AuthorService/Search",
		svc.Search,
		opts...,
	))
	return "/api.AuthorService/", mux
}

// UnimplementedAuthorServiceHandler returns CodeUnimplemented from all methods.
type UnimplementedAuthorServiceHandler struct{}

func (UnimplementedAuthorServiceHandler) Create(context.Context, *connect_go.Request[v1.CreateAuthorRequest]) (*connect_go.Response[v1.Author], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("api.AuthorService.Create is not implemented"))
}

func (UnimplementedAuthorServiceHandler) Get(context.Context, *connect_go.Request[v1.GetAuthorRequest]) (*connect_go.Response[v1.Author], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("api.AuthorService.Get is not implemented"))
}

func (UnimplementedAuthorServiceHandler) Update(context.Context, *connect_go.Request[v1.UpdateAuthorRequest]) (*connect_go.Response[v1.Author], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("api.AuthorService.Update is not implemented"))
}

func (UnimplementedAuthorServiceHandler) Delete(context.Context, *connect_go.Request[v1.DeleteAuthorRequest]) (*connect_go.Response[emptypb.Empty], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("api.AuthorService.Delete is not implemented"))
}

func (UnimplementedAuthorServiceHandler) List(context.Context, *connect_go.Request[v1.ListAuthorRequest]) (*connect_go.Response[v1.ListAuthorResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("api.AuthorService.List is not implemented"))
}

func (UnimplementedAuthorServiceHandler) BatchCreate(context.Context, *connect_go.Request[v1.BatchCreateAuthorsRequest]) (*connect_go.Response[v1.BatchCreateAuthorsResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("api.AuthorService.BatchCreate is not implemented"))
}

func (UnimplementedAuthorServiceHandler) Search(context.Context, *connect_go.Request[v1.SearchAuthorRequest]) (*connect_go.Response[v1.Author], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("api.AuthorService.Search is not implemented"))
}

// ComicServiceClient is a client for the api.ComicService service.
type ComicServiceClient interface {
	Create(context.Context, *connect_go.Request[v1.CreateComicRequest]) (*connect_go.Response[v1.Comic], error)
	Get(context.Context, *connect_go.Request[v1.GetComicRequest]) (*connect_go.Response[v1.Comic], error)
	Update(context.Context, *connect_go.Request[v1.UpdateComicRequest]) (*connect_go.Response[v1.Comic], error)
	Delete(context.Context, *connect_go.Request[v1.DeleteComicRequest]) (*connect_go.Response[emptypb.Empty], error)
	List(context.Context, *connect_go.Request[v1.ListComicRequest]) (*connect_go.Response[v1.ListComicResponse], error)
	BatchCreate(context.Context, *connect_go.Request[v1.BatchCreateComicsRequest]) (*connect_go.Response[v1.BatchCreateComicsResponse], error)
}

// NewComicServiceClient constructs a client for the api.ComicService service. By default, it uses
// the Connect protocol with the binary Protobuf Codec, asks for gzipped responses, and sends
// uncompressed requests. To use the gRPC or gRPC-Web protocols, supply the connect.WithGRPC() or
// connect.WithGRPCWeb() options.
//
// The URL supplied here should be the base URL for the Connect or gRPC server (for example,
// http://api.acme.com or https://acme.com/grpc).
func NewComicServiceClient(httpClient connect_go.HTTPClient, baseURL string, opts ...connect_go.ClientOption) ComicServiceClient {
	baseURL = strings.TrimRight(baseURL, "/")
	return &comicServiceClient{
		create: connect_go.NewClient[v1.CreateComicRequest, v1.Comic](
			httpClient,
			baseURL+"/api.ComicService/Create",
			opts...,
		),
		get: connect_go.NewClient[v1.GetComicRequest, v1.Comic](
			httpClient,
			baseURL+"/api.ComicService/Get",
			opts...,
		),
		update: connect_go.NewClient[v1.UpdateComicRequest, v1.Comic](
			httpClient,
			baseURL+"/api.ComicService/Update",
			opts...,
		),
		delete: connect_go.NewClient[v1.DeleteComicRequest, emptypb.Empty](
			httpClient,
			baseURL+"/api.ComicService/Delete",
			opts...,
		),
		list: connect_go.NewClient[v1.ListComicRequest, v1.ListComicResponse](
			httpClient,
			baseURL+"/api.ComicService/List",
			opts...,
		),
		batchCreate: connect_go.NewClient[v1.BatchCreateComicsRequest, v1.BatchCreateComicsResponse](
			httpClient,
			baseURL+"/api.ComicService/BatchCreate",
			opts...,
		),
	}
}

// comicServiceClient implements ComicServiceClient.
type comicServiceClient struct {
	create      *connect_go.Client[v1.CreateComicRequest, v1.Comic]
	get         *connect_go.Client[v1.GetComicRequest, v1.Comic]
	update      *connect_go.Client[v1.UpdateComicRequest, v1.Comic]
	delete      *connect_go.Client[v1.DeleteComicRequest, emptypb.Empty]
	list        *connect_go.Client[v1.ListComicRequest, v1.ListComicResponse]
	batchCreate *connect_go.Client[v1.BatchCreateComicsRequest, v1.BatchCreateComicsResponse]
}

// Create calls api.ComicService.Create.
func (c *comicServiceClient) Create(ctx context.Context, req *connect_go.Request[v1.CreateComicRequest]) (*connect_go.Response[v1.Comic], error) {
	return c.create.CallUnary(ctx, req)
}

// Get calls api.ComicService.Get.
func (c *comicServiceClient) Get(ctx context.Context, req *connect_go.Request[v1.GetComicRequest]) (*connect_go.Response[v1.Comic], error) {
	return c.get.CallUnary(ctx, req)
}

// Update calls api.ComicService.Update.
func (c *comicServiceClient) Update(ctx context.Context, req *connect_go.Request[v1.UpdateComicRequest]) (*connect_go.Response[v1.Comic], error) {
	return c.update.CallUnary(ctx, req)
}

// Delete calls api.ComicService.Delete.
func (c *comicServiceClient) Delete(ctx context.Context, req *connect_go.Request[v1.DeleteComicRequest]) (*connect_go.Response[emptypb.Empty], error) {
	return c.delete.CallUnary(ctx, req)
}

// List calls api.ComicService.List.
func (c *comicServiceClient) List(ctx context.Context, req *connect_go.Request[v1.ListComicRequest]) (*connect_go.Response[v1.ListComicResponse], error) {
	return c.list.CallUnary(ctx, req)
}

// BatchCreate calls api.ComicService.BatchCreate.
func (c *comicServiceClient) BatchCreate(ctx context.Context, req *connect_go.Request[v1.BatchCreateComicsRequest]) (*connect_go.Response[v1.BatchCreateComicsResponse], error) {
	return c.batchCreate.CallUnary(ctx, req)
}

// ComicServiceHandler is an implementation of the api.ComicService service.
type ComicServiceHandler interface {
	Create(context.Context, *connect_go.Request[v1.CreateComicRequest]) (*connect_go.Response[v1.Comic], error)
	Get(context.Context, *connect_go.Request[v1.GetComicRequest]) (*connect_go.Response[v1.Comic], error)
	Update(context.Context, *connect_go.Request[v1.UpdateComicRequest]) (*connect_go.Response[v1.Comic], error)
	Delete(context.Context, *connect_go.Request[v1.DeleteComicRequest]) (*connect_go.Response[emptypb.Empty], error)
	List(context.Context, *connect_go.Request[v1.ListComicRequest]) (*connect_go.Response[v1.ListComicResponse], error)
	BatchCreate(context.Context, *connect_go.Request[v1.BatchCreateComicsRequest]) (*connect_go.Response[v1.BatchCreateComicsResponse], error)
}

// NewComicServiceHandler builds an HTTP handler from the service implementation. It returns the
// path on which to mount the handler and the handler itself.
//
// By default, handlers support the Connect, gRPC, and gRPC-Web protocols with the binary Protobuf
// and JSON codecs. They also support gzip compression.
func NewComicServiceHandler(svc ComicServiceHandler, opts ...connect_go.HandlerOption) (string, http.Handler) {
	mux := http.NewServeMux()
	mux.Handle("/api.ComicService/Create", connect_go.NewUnaryHandler(
		"/api.ComicService/Create",
		svc.Create,
		opts...,
	))
	mux.Handle("/api.ComicService/Get", connect_go.NewUnaryHandler(
		"/api.ComicService/Get",
		svc.Get,
		opts...,
	))
	mux.Handle("/api.ComicService/Update", connect_go.NewUnaryHandler(
		"/api.ComicService/Update",
		svc.Update,
		opts...,
	))
	mux.Handle("/api.ComicService/Delete", connect_go.NewUnaryHandler(
		"/api.ComicService/Delete",
		svc.Delete,
		opts...,
	))
	mux.Handle("/api.ComicService/List", connect_go.NewUnaryHandler(
		"/api.ComicService/List",
		svc.List,
		opts...,
	))
	mux.Handle("/api.ComicService/BatchCreate", connect_go.NewUnaryHandler(
		"/api.ComicService/BatchCreate",
		svc.BatchCreate,
		opts...,
	))
	return "/api.ComicService/", mux
}

// UnimplementedComicServiceHandler returns CodeUnimplemented from all methods.
type UnimplementedComicServiceHandler struct{}

func (UnimplementedComicServiceHandler) Create(context.Context, *connect_go.Request[v1.CreateComicRequest]) (*connect_go.Response[v1.Comic], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("api.ComicService.Create is not implemented"))
}

func (UnimplementedComicServiceHandler) Get(context.Context, *connect_go.Request[v1.GetComicRequest]) (*connect_go.Response[v1.Comic], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("api.ComicService.Get is not implemented"))
}

func (UnimplementedComicServiceHandler) Update(context.Context, *connect_go.Request[v1.UpdateComicRequest]) (*connect_go.Response[v1.Comic], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("api.ComicService.Update is not implemented"))
}

func (UnimplementedComicServiceHandler) Delete(context.Context, *connect_go.Request[v1.DeleteComicRequest]) (*connect_go.Response[emptypb.Empty], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("api.ComicService.Delete is not implemented"))
}

func (UnimplementedComicServiceHandler) List(context.Context, *connect_go.Request[v1.ListComicRequest]) (*connect_go.Response[v1.ListComicResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("api.ComicService.List is not implemented"))
}

func (UnimplementedComicServiceHandler) BatchCreate(context.Context, *connect_go.Request[v1.BatchCreateComicsRequest]) (*connect_go.Response[v1.BatchCreateComicsResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("api.ComicService.BatchCreate is not implemented"))
}

// EpisodeServiceClient is a client for the api.EpisodeService service.
type EpisodeServiceClient interface {
	Create(context.Context, *connect_go.Request[v1.CreateEpisodeRequest]) (*connect_go.Response[v1.Episode], error)
	Get(context.Context, *connect_go.Request[v1.GetEpisodeRequest]) (*connect_go.Response[v1.Episode], error)
	Update(context.Context, *connect_go.Request[v1.UpdateEpisodeRequest]) (*connect_go.Response[v1.Episode], error)
	Delete(context.Context, *connect_go.Request[v1.DeleteEpisodeRequest]) (*connect_go.Response[emptypb.Empty], error)
	List(context.Context, *connect_go.Request[v1.ListEpisodeRequest]) (*connect_go.Response[v1.ListEpisodeResponse], error)
	BatchCreate(context.Context, *connect_go.Request[v1.BatchCreateEpisodesRequest]) (*connect_go.Response[v1.BatchCreateEpisodesResponse], error)
}

// NewEpisodeServiceClient constructs a client for the api.EpisodeService service. By default, it
// uses the Connect protocol with the binary Protobuf Codec, asks for gzipped responses, and sends
// uncompressed requests. To use the gRPC or gRPC-Web protocols, supply the connect.WithGRPC() or
// connect.WithGRPCWeb() options.
//
// The URL supplied here should be the base URL for the Connect or gRPC server (for example,
// http://api.acme.com or https://acme.com/grpc).
func NewEpisodeServiceClient(httpClient connect_go.HTTPClient, baseURL string, opts ...connect_go.ClientOption) EpisodeServiceClient {
	baseURL = strings.TrimRight(baseURL, "/")
	return &episodeServiceClient{
		create: connect_go.NewClient[v1.CreateEpisodeRequest, v1.Episode](
			httpClient,
			baseURL+"/api.EpisodeService/Create",
			opts...,
		),
		get: connect_go.NewClient[v1.GetEpisodeRequest, v1.Episode](
			httpClient,
			baseURL+"/api.EpisodeService/Get",
			opts...,
		),
		update: connect_go.NewClient[v1.UpdateEpisodeRequest, v1.Episode](
			httpClient,
			baseURL+"/api.EpisodeService/Update",
			opts...,
		),
		delete: connect_go.NewClient[v1.DeleteEpisodeRequest, emptypb.Empty](
			httpClient,
			baseURL+"/api.EpisodeService/Delete",
			opts...,
		),
		list: connect_go.NewClient[v1.ListEpisodeRequest, v1.ListEpisodeResponse](
			httpClient,
			baseURL+"/api.EpisodeService/List",
			opts...,
		),
		batchCreate: connect_go.NewClient[v1.BatchCreateEpisodesRequest, v1.BatchCreateEpisodesResponse](
			httpClient,
			baseURL+"/api.EpisodeService/BatchCreate",
			opts...,
		),
	}
}

// episodeServiceClient implements EpisodeServiceClient.
type episodeServiceClient struct {
	create      *connect_go.Client[v1.CreateEpisodeRequest, v1.Episode]
	get         *connect_go.Client[v1.GetEpisodeRequest, v1.Episode]
	update      *connect_go.Client[v1.UpdateEpisodeRequest, v1.Episode]
	delete      *connect_go.Client[v1.DeleteEpisodeRequest, emptypb.Empty]
	list        *connect_go.Client[v1.ListEpisodeRequest, v1.ListEpisodeResponse]
	batchCreate *connect_go.Client[v1.BatchCreateEpisodesRequest, v1.BatchCreateEpisodesResponse]
}

// Create calls api.EpisodeService.Create.
func (c *episodeServiceClient) Create(ctx context.Context, req *connect_go.Request[v1.CreateEpisodeRequest]) (*connect_go.Response[v1.Episode], error) {
	return c.create.CallUnary(ctx, req)
}

// Get calls api.EpisodeService.Get.
func (c *episodeServiceClient) Get(ctx context.Context, req *connect_go.Request[v1.GetEpisodeRequest]) (*connect_go.Response[v1.Episode], error) {
	return c.get.CallUnary(ctx, req)
}

// Update calls api.EpisodeService.Update.
func (c *episodeServiceClient) Update(ctx context.Context, req *connect_go.Request[v1.UpdateEpisodeRequest]) (*connect_go.Response[v1.Episode], error) {
	return c.update.CallUnary(ctx, req)
}

// Delete calls api.EpisodeService.Delete.
func (c *episodeServiceClient) Delete(ctx context.Context, req *connect_go.Request[v1.DeleteEpisodeRequest]) (*connect_go.Response[emptypb.Empty], error) {
	return c.delete.CallUnary(ctx, req)
}

// List calls api.EpisodeService.List.
func (c *episodeServiceClient) List(ctx context.Context, req *connect_go.Request[v1.ListEpisodeRequest]) (*connect_go.Response[v1.ListEpisodeResponse], error) {
	return c.list.CallUnary(ctx, req)
}

// BatchCreate calls api.EpisodeService.BatchCreate.
func (c *episodeServiceClient) BatchCreate(ctx context.Context, req *connect_go.Request[v1.BatchCreateEpisodesRequest]) (*connect_go.Response[v1.BatchCreateEpisodesResponse], error) {
	return c.batchCreate.CallUnary(ctx, req)
}

// EpisodeServiceHandler is an implementation of the api.EpisodeService service.
type EpisodeServiceHandler interface {
	Create(context.Context, *connect_go.Request[v1.CreateEpisodeRequest]) (*connect_go.Response[v1.Episode], error)
	Get(context.Context, *connect_go.Request[v1.GetEpisodeRequest]) (*connect_go.Response[v1.Episode], error)
	Update(context.Context, *connect_go.Request[v1.UpdateEpisodeRequest]) (*connect_go.Response[v1.Episode], error)
	Delete(context.Context, *connect_go.Request[v1.DeleteEpisodeRequest]) (*connect_go.Response[emptypb.Empty], error)
	List(context.Context, *connect_go.Request[v1.ListEpisodeRequest]) (*connect_go.Response[v1.ListEpisodeResponse], error)
	BatchCreate(context.Context, *connect_go.Request[v1.BatchCreateEpisodesRequest]) (*connect_go.Response[v1.BatchCreateEpisodesResponse], error)
}

// NewEpisodeServiceHandler builds an HTTP handler from the service implementation. It returns the
// path on which to mount the handler and the handler itself.
//
// By default, handlers support the Connect, gRPC, and gRPC-Web protocols with the binary Protobuf
// and JSON codecs. They also support gzip compression.
func NewEpisodeServiceHandler(svc EpisodeServiceHandler, opts ...connect_go.HandlerOption) (string, http.Handler) {
	mux := http.NewServeMux()
	mux.Handle("/api.EpisodeService/Create", connect_go.NewUnaryHandler(
		"/api.EpisodeService/Create",
		svc.Create,
		opts...,
	))
	mux.Handle("/api.EpisodeService/Get", connect_go.NewUnaryHandler(
		"/api.EpisodeService/Get",
		svc.Get,
		opts...,
	))
	mux.Handle("/api.EpisodeService/Update", connect_go.NewUnaryHandler(
		"/api.EpisodeService/Update",
		svc.Update,
		opts...,
	))
	mux.Handle("/api.EpisodeService/Delete", connect_go.NewUnaryHandler(
		"/api.EpisodeService/Delete",
		svc.Delete,
		opts...,
	))
	mux.Handle("/api.EpisodeService/List", connect_go.NewUnaryHandler(
		"/api.EpisodeService/List",
		svc.List,
		opts...,
	))
	mux.Handle("/api.EpisodeService/BatchCreate", connect_go.NewUnaryHandler(
		"/api.EpisodeService/BatchCreate",
		svc.BatchCreate,
		opts...,
	))
	return "/api.EpisodeService/", mux
}

// UnimplementedEpisodeServiceHandler returns CodeUnimplemented from all methods.
type UnimplementedEpisodeServiceHandler struct{}

func (UnimplementedEpisodeServiceHandler) Create(context.Context, *connect_go.Request[v1.CreateEpisodeRequest]) (*connect_go.Response[v1.Episode], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("api.EpisodeService.Create is not implemented"))
}

func (UnimplementedEpisodeServiceHandler) Get(context.Context, *connect_go.Request[v1.GetEpisodeRequest]) (*connect_go.Response[v1.Episode], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("api.EpisodeService.Get is not implemented"))
}

func (UnimplementedEpisodeServiceHandler) Update(context.Context, *connect_go.Request[v1.UpdateEpisodeRequest]) (*connect_go.Response[v1.Episode], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("api.EpisodeService.Update is not implemented"))
}

func (UnimplementedEpisodeServiceHandler) Delete(context.Context, *connect_go.Request[v1.DeleteEpisodeRequest]) (*connect_go.Response[emptypb.Empty], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("api.EpisodeService.Delete is not implemented"))
}

func (UnimplementedEpisodeServiceHandler) List(context.Context, *connect_go.Request[v1.ListEpisodeRequest]) (*connect_go.Response[v1.ListEpisodeResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("api.EpisodeService.List is not implemented"))
}

func (UnimplementedEpisodeServiceHandler) BatchCreate(context.Context, *connect_go.Request[v1.BatchCreateEpisodesRequest]) (*connect_go.Response[v1.BatchCreateEpisodesResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("api.EpisodeService.BatchCreate is not implemented"))
}

// MagazineServiceClient is a client for the api.MagazineService service.
type MagazineServiceClient interface {
	Create(context.Context, *connect_go.Request[v1.CreateMagazineRequest]) (*connect_go.Response[v1.Magazine], error)
	Get(context.Context, *connect_go.Request[v1.GetMagazineRequest]) (*connect_go.Response[v1.Magazine], error)
	Update(context.Context, *connect_go.Request[v1.UpdateMagazineRequest]) (*connect_go.Response[v1.Magazine], error)
	Delete(context.Context, *connect_go.Request[v1.DeleteMagazineRequest]) (*connect_go.Response[emptypb.Empty], error)
	List(context.Context, *connect_go.Request[v1.ListMagazineRequest]) (*connect_go.Response[v1.ListMagazineResponse], error)
	BatchCreate(context.Context, *connect_go.Request[v1.BatchCreateMagazinesRequest]) (*connect_go.Response[v1.BatchCreateMagazinesResponse], error)
}

// NewMagazineServiceClient constructs a client for the api.MagazineService service. By default, it
// uses the Connect protocol with the binary Protobuf Codec, asks for gzipped responses, and sends
// uncompressed requests. To use the gRPC or gRPC-Web protocols, supply the connect.WithGRPC() or
// connect.WithGRPCWeb() options.
//
// The URL supplied here should be the base URL for the Connect or gRPC server (for example,
// http://api.acme.com or https://acme.com/grpc).
func NewMagazineServiceClient(httpClient connect_go.HTTPClient, baseURL string, opts ...connect_go.ClientOption) MagazineServiceClient {
	baseURL = strings.TrimRight(baseURL, "/")
	return &magazineServiceClient{
		create: connect_go.NewClient[v1.CreateMagazineRequest, v1.Magazine](
			httpClient,
			baseURL+"/api.MagazineService/Create",
			opts...,
		),
		get: connect_go.NewClient[v1.GetMagazineRequest, v1.Magazine](
			httpClient,
			baseURL+"/api.MagazineService/Get",
			opts...,
		),
		update: connect_go.NewClient[v1.UpdateMagazineRequest, v1.Magazine](
			httpClient,
			baseURL+"/api.MagazineService/Update",
			opts...,
		),
		delete: connect_go.NewClient[v1.DeleteMagazineRequest, emptypb.Empty](
			httpClient,
			baseURL+"/api.MagazineService/Delete",
			opts...,
		),
		list: connect_go.NewClient[v1.ListMagazineRequest, v1.ListMagazineResponse](
			httpClient,
			baseURL+"/api.MagazineService/List",
			opts...,
		),
		batchCreate: connect_go.NewClient[v1.BatchCreateMagazinesRequest, v1.BatchCreateMagazinesResponse](
			httpClient,
			baseURL+"/api.MagazineService/BatchCreate",
			opts...,
		),
	}
}

// magazineServiceClient implements MagazineServiceClient.
type magazineServiceClient struct {
	create      *connect_go.Client[v1.CreateMagazineRequest, v1.Magazine]
	get         *connect_go.Client[v1.GetMagazineRequest, v1.Magazine]
	update      *connect_go.Client[v1.UpdateMagazineRequest, v1.Magazine]
	delete      *connect_go.Client[v1.DeleteMagazineRequest, emptypb.Empty]
	list        *connect_go.Client[v1.ListMagazineRequest, v1.ListMagazineResponse]
	batchCreate *connect_go.Client[v1.BatchCreateMagazinesRequest, v1.BatchCreateMagazinesResponse]
}

// Create calls api.MagazineService.Create.
func (c *magazineServiceClient) Create(ctx context.Context, req *connect_go.Request[v1.CreateMagazineRequest]) (*connect_go.Response[v1.Magazine], error) {
	return c.create.CallUnary(ctx, req)
}

// Get calls api.MagazineService.Get.
func (c *magazineServiceClient) Get(ctx context.Context, req *connect_go.Request[v1.GetMagazineRequest]) (*connect_go.Response[v1.Magazine], error) {
	return c.get.CallUnary(ctx, req)
}

// Update calls api.MagazineService.Update.
func (c *magazineServiceClient) Update(ctx context.Context, req *connect_go.Request[v1.UpdateMagazineRequest]) (*connect_go.Response[v1.Magazine], error) {
	return c.update.CallUnary(ctx, req)
}

// Delete calls api.MagazineService.Delete.
func (c *magazineServiceClient) Delete(ctx context.Context, req *connect_go.Request[v1.DeleteMagazineRequest]) (*connect_go.Response[emptypb.Empty], error) {
	return c.delete.CallUnary(ctx, req)
}

// List calls api.MagazineService.List.
func (c *magazineServiceClient) List(ctx context.Context, req *connect_go.Request[v1.ListMagazineRequest]) (*connect_go.Response[v1.ListMagazineResponse], error) {
	return c.list.CallUnary(ctx, req)
}

// BatchCreate calls api.MagazineService.BatchCreate.
func (c *magazineServiceClient) BatchCreate(ctx context.Context, req *connect_go.Request[v1.BatchCreateMagazinesRequest]) (*connect_go.Response[v1.BatchCreateMagazinesResponse], error) {
	return c.batchCreate.CallUnary(ctx, req)
}

// MagazineServiceHandler is an implementation of the api.MagazineService service.
type MagazineServiceHandler interface {
	Create(context.Context, *connect_go.Request[v1.CreateMagazineRequest]) (*connect_go.Response[v1.Magazine], error)
	Get(context.Context, *connect_go.Request[v1.GetMagazineRequest]) (*connect_go.Response[v1.Magazine], error)
	Update(context.Context, *connect_go.Request[v1.UpdateMagazineRequest]) (*connect_go.Response[v1.Magazine], error)
	Delete(context.Context, *connect_go.Request[v1.DeleteMagazineRequest]) (*connect_go.Response[emptypb.Empty], error)
	List(context.Context, *connect_go.Request[v1.ListMagazineRequest]) (*connect_go.Response[v1.ListMagazineResponse], error)
	BatchCreate(context.Context, *connect_go.Request[v1.BatchCreateMagazinesRequest]) (*connect_go.Response[v1.BatchCreateMagazinesResponse], error)
}

// NewMagazineServiceHandler builds an HTTP handler from the service implementation. It returns the
// path on which to mount the handler and the handler itself.
//
// By default, handlers support the Connect, gRPC, and gRPC-Web protocols with the binary Protobuf
// and JSON codecs. They also support gzip compression.
func NewMagazineServiceHandler(svc MagazineServiceHandler, opts ...connect_go.HandlerOption) (string, http.Handler) {
	mux := http.NewServeMux()
	mux.Handle("/api.MagazineService/Create", connect_go.NewUnaryHandler(
		"/api.MagazineService/Create",
		svc.Create,
		opts...,
	))
	mux.Handle("/api.MagazineService/Get", connect_go.NewUnaryHandler(
		"/api.MagazineService/Get",
		svc.Get,
		opts...,
	))
	mux.Handle("/api.MagazineService/Update", connect_go.NewUnaryHandler(
		"/api.MagazineService/Update",
		svc.Update,
		opts...,
	))
	mux.Handle("/api.MagazineService/Delete", connect_go.NewUnaryHandler(
		"/api.MagazineService/Delete",
		svc.Delete,
		opts...,
	))
	mux.Handle("/api.MagazineService/List", connect_go.NewUnaryHandler(
		"/api.MagazineService/List",
		svc.List,
		opts...,
	))
	mux.Handle("/api.MagazineService/BatchCreate", connect_go.NewUnaryHandler(
		"/api.MagazineService/BatchCreate",
		svc.BatchCreate,
		opts...,
	))
	return "/api.MagazineService/", mux
}

// UnimplementedMagazineServiceHandler returns CodeUnimplemented from all methods.
type UnimplementedMagazineServiceHandler struct{}

func (UnimplementedMagazineServiceHandler) Create(context.Context, *connect_go.Request[v1.CreateMagazineRequest]) (*connect_go.Response[v1.Magazine], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("api.MagazineService.Create is not implemented"))
}

func (UnimplementedMagazineServiceHandler) Get(context.Context, *connect_go.Request[v1.GetMagazineRequest]) (*connect_go.Response[v1.Magazine], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("api.MagazineService.Get is not implemented"))
}

func (UnimplementedMagazineServiceHandler) Update(context.Context, *connect_go.Request[v1.UpdateMagazineRequest]) (*connect_go.Response[v1.Magazine], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("api.MagazineService.Update is not implemented"))
}

func (UnimplementedMagazineServiceHandler) Delete(context.Context, *connect_go.Request[v1.DeleteMagazineRequest]) (*connect_go.Response[emptypb.Empty], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("api.MagazineService.Delete is not implemented"))
}

func (UnimplementedMagazineServiceHandler) List(context.Context, *connect_go.Request[v1.ListMagazineRequest]) (*connect_go.Response[v1.ListMagazineResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("api.MagazineService.List is not implemented"))
}

func (UnimplementedMagazineServiceHandler) BatchCreate(context.Context, *connect_go.Request[v1.BatchCreateMagazinesRequest]) (*connect_go.Response[v1.BatchCreateMagazinesResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("api.MagazineService.BatchCreate is not implemented"))
}

// TagServiceClient is a client for the api.TagService service.
type TagServiceClient interface {
	Create(context.Context, *connect_go.Request[v1.CreateTagRequest]) (*connect_go.Response[v1.Tag], error)
	Get(context.Context, *connect_go.Request[v1.GetTagRequest]) (*connect_go.Response[v1.Tag], error)
	Update(context.Context, *connect_go.Request[v1.UpdateTagRequest]) (*connect_go.Response[v1.Tag], error)
	Delete(context.Context, *connect_go.Request[v1.DeleteTagRequest]) (*connect_go.Response[emptypb.Empty], error)
	List(context.Context, *connect_go.Request[v1.ListTagRequest]) (*connect_go.Response[v1.ListTagResponse], error)
	BatchCreate(context.Context, *connect_go.Request[v1.BatchCreateTagsRequest]) (*connect_go.Response[v1.BatchCreateTagsResponse], error)
}

// NewTagServiceClient constructs a client for the api.TagService service. By default, it uses the
// Connect protocol with the binary Protobuf Codec, asks for gzipped responses, and sends
// uncompressed requests. To use the gRPC or gRPC-Web protocols, supply the connect.WithGRPC() or
// connect.WithGRPCWeb() options.
//
// The URL supplied here should be the base URL for the Connect or gRPC server (for example,
// http://api.acme.com or https://acme.com/grpc).
func NewTagServiceClient(httpClient connect_go.HTTPClient, baseURL string, opts ...connect_go.ClientOption) TagServiceClient {
	baseURL = strings.TrimRight(baseURL, "/")
	return &tagServiceClient{
		create: connect_go.NewClient[v1.CreateTagRequest, v1.Tag](
			httpClient,
			baseURL+"/api.TagService/Create",
			opts...,
		),
		get: connect_go.NewClient[v1.GetTagRequest, v1.Tag](
			httpClient,
			baseURL+"/api.TagService/Get",
			opts...,
		),
		update: connect_go.NewClient[v1.UpdateTagRequest, v1.Tag](
			httpClient,
			baseURL+"/api.TagService/Update",
			opts...,
		),
		delete: connect_go.NewClient[v1.DeleteTagRequest, emptypb.Empty](
			httpClient,
			baseURL+"/api.TagService/Delete",
			opts...,
		),
		list: connect_go.NewClient[v1.ListTagRequest, v1.ListTagResponse](
			httpClient,
			baseURL+"/api.TagService/List",
			opts...,
		),
		batchCreate: connect_go.NewClient[v1.BatchCreateTagsRequest, v1.BatchCreateTagsResponse](
			httpClient,
			baseURL+"/api.TagService/BatchCreate",
			opts...,
		),
	}
}

// tagServiceClient implements TagServiceClient.
type tagServiceClient struct {
	create      *connect_go.Client[v1.CreateTagRequest, v1.Tag]
	get         *connect_go.Client[v1.GetTagRequest, v1.Tag]
	update      *connect_go.Client[v1.UpdateTagRequest, v1.Tag]
	delete      *connect_go.Client[v1.DeleteTagRequest, emptypb.Empty]
	list        *connect_go.Client[v1.ListTagRequest, v1.ListTagResponse]
	batchCreate *connect_go.Client[v1.BatchCreateTagsRequest, v1.BatchCreateTagsResponse]
}

// Create calls api.TagService.Create.
func (c *tagServiceClient) Create(ctx context.Context, req *connect_go.Request[v1.CreateTagRequest]) (*connect_go.Response[v1.Tag], error) {
	return c.create.CallUnary(ctx, req)
}

// Get calls api.TagService.Get.
func (c *tagServiceClient) Get(ctx context.Context, req *connect_go.Request[v1.GetTagRequest]) (*connect_go.Response[v1.Tag], error) {
	return c.get.CallUnary(ctx, req)
}

// Update calls api.TagService.Update.
func (c *tagServiceClient) Update(ctx context.Context, req *connect_go.Request[v1.UpdateTagRequest]) (*connect_go.Response[v1.Tag], error) {
	return c.update.CallUnary(ctx, req)
}

// Delete calls api.TagService.Delete.
func (c *tagServiceClient) Delete(ctx context.Context, req *connect_go.Request[v1.DeleteTagRequest]) (*connect_go.Response[emptypb.Empty], error) {
	return c.delete.CallUnary(ctx, req)
}

// List calls api.TagService.List.
func (c *tagServiceClient) List(ctx context.Context, req *connect_go.Request[v1.ListTagRequest]) (*connect_go.Response[v1.ListTagResponse], error) {
	return c.list.CallUnary(ctx, req)
}

// BatchCreate calls api.TagService.BatchCreate.
func (c *tagServiceClient) BatchCreate(ctx context.Context, req *connect_go.Request[v1.BatchCreateTagsRequest]) (*connect_go.Response[v1.BatchCreateTagsResponse], error) {
	return c.batchCreate.CallUnary(ctx, req)
}

// TagServiceHandler is an implementation of the api.TagService service.
type TagServiceHandler interface {
	Create(context.Context, *connect_go.Request[v1.CreateTagRequest]) (*connect_go.Response[v1.Tag], error)
	Get(context.Context, *connect_go.Request[v1.GetTagRequest]) (*connect_go.Response[v1.Tag], error)
	Update(context.Context, *connect_go.Request[v1.UpdateTagRequest]) (*connect_go.Response[v1.Tag], error)
	Delete(context.Context, *connect_go.Request[v1.DeleteTagRequest]) (*connect_go.Response[emptypb.Empty], error)
	List(context.Context, *connect_go.Request[v1.ListTagRequest]) (*connect_go.Response[v1.ListTagResponse], error)
	BatchCreate(context.Context, *connect_go.Request[v1.BatchCreateTagsRequest]) (*connect_go.Response[v1.BatchCreateTagsResponse], error)
}

// NewTagServiceHandler builds an HTTP handler from the service implementation. It returns the path
// on which to mount the handler and the handler itself.
//
// By default, handlers support the Connect, gRPC, and gRPC-Web protocols with the binary Protobuf
// and JSON codecs. They also support gzip compression.
func NewTagServiceHandler(svc TagServiceHandler, opts ...connect_go.HandlerOption) (string, http.Handler) {
	mux := http.NewServeMux()
	mux.Handle("/api.TagService/Create", connect_go.NewUnaryHandler(
		"/api.TagService/Create",
		svc.Create,
		opts...,
	))
	mux.Handle("/api.TagService/Get", connect_go.NewUnaryHandler(
		"/api.TagService/Get",
		svc.Get,
		opts...,
	))
	mux.Handle("/api.TagService/Update", connect_go.NewUnaryHandler(
		"/api.TagService/Update",
		svc.Update,
		opts...,
	))
	mux.Handle("/api.TagService/Delete", connect_go.NewUnaryHandler(
		"/api.TagService/Delete",
		svc.Delete,
		opts...,
	))
	mux.Handle("/api.TagService/List", connect_go.NewUnaryHandler(
		"/api.TagService/List",
		svc.List,
		opts...,
	))
	mux.Handle("/api.TagService/BatchCreate", connect_go.NewUnaryHandler(
		"/api.TagService/BatchCreate",
		svc.BatchCreate,
		opts...,
	))
	return "/api.TagService/", mux
}

// UnimplementedTagServiceHandler returns CodeUnimplemented from all methods.
type UnimplementedTagServiceHandler struct{}

func (UnimplementedTagServiceHandler) Create(context.Context, *connect_go.Request[v1.CreateTagRequest]) (*connect_go.Response[v1.Tag], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("api.TagService.Create is not implemented"))
}

func (UnimplementedTagServiceHandler) Get(context.Context, *connect_go.Request[v1.GetTagRequest]) (*connect_go.Response[v1.Tag], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("api.TagService.Get is not implemented"))
}

func (UnimplementedTagServiceHandler) Update(context.Context, *connect_go.Request[v1.UpdateTagRequest]) (*connect_go.Response[v1.Tag], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("api.TagService.Update is not implemented"))
}

func (UnimplementedTagServiceHandler) Delete(context.Context, *connect_go.Request[v1.DeleteTagRequest]) (*connect_go.Response[emptypb.Empty], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("api.TagService.Delete is not implemented"))
}

func (UnimplementedTagServiceHandler) List(context.Context, *connect_go.Request[v1.ListTagRequest]) (*connect_go.Response[v1.ListTagResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("api.TagService.List is not implemented"))
}

func (UnimplementedTagServiceHandler) BatchCreate(context.Context, *connect_go.Request[v1.BatchCreateTagsRequest]) (*connect_go.Response[v1.BatchCreateTagsResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("api.TagService.BatchCreate is not implemented"))
}
