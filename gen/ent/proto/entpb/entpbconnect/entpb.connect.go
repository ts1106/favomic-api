// Code generated by protoc-gen-connect-go. DO NOT EDIT.
//
// Source: ent/proto/entpb/entpb.proto

package entpbconnect

import (
	context "context"
	errors "errors"
	connect_go "github.com/bufbuild/connect-go"
	entpb "github.com/ts1106/favomic-api/gen/ent/proto/entpb"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	http "net/http"
	strings "strings"
)

// This is a compile-time assertion to ensure that this generated file and the connect package are
// compatible. If you get a compiler error that this constant is not defined, this code was
// generated with a version of connect newer than the one compiled into your binary. You can fix the
// problem by either regenerating this code with an older version of connect or updating the connect
// version compiled into your binary.
const _ = connect_go.IsAtLeastVersion0_1_0

const (
	// AuthorServiceName is the fully-qualified name of the AuthorService service.
	AuthorServiceName = "entpb.AuthorService"
	// ComicServiceName is the fully-qualified name of the ComicService service.
	ComicServiceName = "entpb.ComicService"
	// EpisodeServiceName is the fully-qualified name of the EpisodeService service.
	EpisodeServiceName = "entpb.EpisodeService"
	// MagazineServiceName is the fully-qualified name of the MagazineService service.
	MagazineServiceName = "entpb.MagazineService"
	// TagServiceName is the fully-qualified name of the TagService service.
	TagServiceName = "entpb.TagService"
)

// AuthorServiceClient is a client for the entpb.AuthorService service.
type AuthorServiceClient interface {
	Create(context.Context, *connect_go.Request[entpb.CreateAuthorRequest]) (*connect_go.Response[entpb.Author], error)
	Get(context.Context, *connect_go.Request[entpb.GetAuthorRequest]) (*connect_go.Response[entpb.Author], error)
	Update(context.Context, *connect_go.Request[entpb.UpdateAuthorRequest]) (*connect_go.Response[entpb.Author], error)
	Delete(context.Context, *connect_go.Request[entpb.DeleteAuthorRequest]) (*connect_go.Response[emptypb.Empty], error)
	List(context.Context, *connect_go.Request[entpb.ListAuthorRequest]) (*connect_go.Response[entpb.ListAuthorResponse], error)
	BatchCreate(context.Context, *connect_go.Request[entpb.BatchCreateAuthorsRequest]) (*connect_go.Response[entpb.BatchCreateAuthorsResponse], error)
}

// NewAuthorServiceClient constructs a client for the entpb.AuthorService service. By default, it
// uses the Connect protocol with the binary Protobuf Codec, asks for gzipped responses, and sends
// uncompressed requests. To use the gRPC or gRPC-Web protocols, supply the connect.WithGRPC() or
// connect.WithGRPCWeb() options.
//
// The URL supplied here should be the base URL for the Connect or gRPC server (for example,
// http://api.acme.com or https://acme.com/grpc).
func NewAuthorServiceClient(httpClient connect_go.HTTPClient, baseURL string, opts ...connect_go.ClientOption) AuthorServiceClient {
	baseURL = strings.TrimRight(baseURL, "/")
	return &authorServiceClient{
		create: connect_go.NewClient[entpb.CreateAuthorRequest, entpb.Author](
			httpClient,
			baseURL+"/entpb.AuthorService/Create",
			opts...,
		),
		get: connect_go.NewClient[entpb.GetAuthorRequest, entpb.Author](
			httpClient,
			baseURL+"/entpb.AuthorService/Get",
			opts...,
		),
		update: connect_go.NewClient[entpb.UpdateAuthorRequest, entpb.Author](
			httpClient,
			baseURL+"/entpb.AuthorService/Update",
			opts...,
		),
		delete: connect_go.NewClient[entpb.DeleteAuthorRequest, emptypb.Empty](
			httpClient,
			baseURL+"/entpb.AuthorService/Delete",
			opts...,
		),
		list: connect_go.NewClient[entpb.ListAuthorRequest, entpb.ListAuthorResponse](
			httpClient,
			baseURL+"/entpb.AuthorService/List",
			opts...,
		),
		batchCreate: connect_go.NewClient[entpb.BatchCreateAuthorsRequest, entpb.BatchCreateAuthorsResponse](
			httpClient,
			baseURL+"/entpb.AuthorService/BatchCreate",
			opts...,
		),
	}
}

// authorServiceClient implements AuthorServiceClient.
type authorServiceClient struct {
	create      *connect_go.Client[entpb.CreateAuthorRequest, entpb.Author]
	get         *connect_go.Client[entpb.GetAuthorRequest, entpb.Author]
	update      *connect_go.Client[entpb.UpdateAuthorRequest, entpb.Author]
	delete      *connect_go.Client[entpb.DeleteAuthorRequest, emptypb.Empty]
	list        *connect_go.Client[entpb.ListAuthorRequest, entpb.ListAuthorResponse]
	batchCreate *connect_go.Client[entpb.BatchCreateAuthorsRequest, entpb.BatchCreateAuthorsResponse]
}

// Create calls entpb.AuthorService.Create.
func (c *authorServiceClient) Create(ctx context.Context, req *connect_go.Request[entpb.CreateAuthorRequest]) (*connect_go.Response[entpb.Author], error) {
	return c.create.CallUnary(ctx, req)
}

// Get calls entpb.AuthorService.Get.
func (c *authorServiceClient) Get(ctx context.Context, req *connect_go.Request[entpb.GetAuthorRequest]) (*connect_go.Response[entpb.Author], error) {
	return c.get.CallUnary(ctx, req)
}

// Update calls entpb.AuthorService.Update.
func (c *authorServiceClient) Update(ctx context.Context, req *connect_go.Request[entpb.UpdateAuthorRequest]) (*connect_go.Response[entpb.Author], error) {
	return c.update.CallUnary(ctx, req)
}

// Delete calls entpb.AuthorService.Delete.
func (c *authorServiceClient) Delete(ctx context.Context, req *connect_go.Request[entpb.DeleteAuthorRequest]) (*connect_go.Response[emptypb.Empty], error) {
	return c.delete.CallUnary(ctx, req)
}

// List calls entpb.AuthorService.List.
func (c *authorServiceClient) List(ctx context.Context, req *connect_go.Request[entpb.ListAuthorRequest]) (*connect_go.Response[entpb.ListAuthorResponse], error) {
	return c.list.CallUnary(ctx, req)
}

// BatchCreate calls entpb.AuthorService.BatchCreate.
func (c *authorServiceClient) BatchCreate(ctx context.Context, req *connect_go.Request[entpb.BatchCreateAuthorsRequest]) (*connect_go.Response[entpb.BatchCreateAuthorsResponse], error) {
	return c.batchCreate.CallUnary(ctx, req)
}

// AuthorServiceHandler is an implementation of the entpb.AuthorService service.
type AuthorServiceHandler interface {
	Create(context.Context, *connect_go.Request[entpb.CreateAuthorRequest]) (*connect_go.Response[entpb.Author], error)
	Get(context.Context, *connect_go.Request[entpb.GetAuthorRequest]) (*connect_go.Response[entpb.Author], error)
	Update(context.Context, *connect_go.Request[entpb.UpdateAuthorRequest]) (*connect_go.Response[entpb.Author], error)
	Delete(context.Context, *connect_go.Request[entpb.DeleteAuthorRequest]) (*connect_go.Response[emptypb.Empty], error)
	List(context.Context, *connect_go.Request[entpb.ListAuthorRequest]) (*connect_go.Response[entpb.ListAuthorResponse], error)
	BatchCreate(context.Context, *connect_go.Request[entpb.BatchCreateAuthorsRequest]) (*connect_go.Response[entpb.BatchCreateAuthorsResponse], error)
}

// NewAuthorServiceHandler builds an HTTP handler from the service implementation. It returns the
// path on which to mount the handler and the handler itself.
//
// By default, handlers support the Connect, gRPC, and gRPC-Web protocols with the binary Protobuf
// and JSON codecs. They also support gzip compression.
func NewAuthorServiceHandler(svc AuthorServiceHandler, opts ...connect_go.HandlerOption) (string, http.Handler) {
	mux := http.NewServeMux()
	mux.Handle("/entpb.AuthorService/Create", connect_go.NewUnaryHandler(
		"/entpb.AuthorService/Create",
		svc.Create,
		opts...,
	))
	mux.Handle("/entpb.AuthorService/Get", connect_go.NewUnaryHandler(
		"/entpb.AuthorService/Get",
		svc.Get,
		opts...,
	))
	mux.Handle("/entpb.AuthorService/Update", connect_go.NewUnaryHandler(
		"/entpb.AuthorService/Update",
		svc.Update,
		opts...,
	))
	mux.Handle("/entpb.AuthorService/Delete", connect_go.NewUnaryHandler(
		"/entpb.AuthorService/Delete",
		svc.Delete,
		opts...,
	))
	mux.Handle("/entpb.AuthorService/List", connect_go.NewUnaryHandler(
		"/entpb.AuthorService/List",
		svc.List,
		opts...,
	))
	mux.Handle("/entpb.AuthorService/BatchCreate", connect_go.NewUnaryHandler(
		"/entpb.AuthorService/BatchCreate",
		svc.BatchCreate,
		opts...,
	))
	return "/entpb.AuthorService/", mux
}

// UnimplementedAuthorServiceHandler returns CodeUnimplemented from all methods.
type UnimplementedAuthorServiceHandler struct{}

func (UnimplementedAuthorServiceHandler) Create(context.Context, *connect_go.Request[entpb.CreateAuthorRequest]) (*connect_go.Response[entpb.Author], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("entpb.AuthorService.Create is not implemented"))
}

func (UnimplementedAuthorServiceHandler) Get(context.Context, *connect_go.Request[entpb.GetAuthorRequest]) (*connect_go.Response[entpb.Author], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("entpb.AuthorService.Get is not implemented"))
}

func (UnimplementedAuthorServiceHandler) Update(context.Context, *connect_go.Request[entpb.UpdateAuthorRequest]) (*connect_go.Response[entpb.Author], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("entpb.AuthorService.Update is not implemented"))
}

func (UnimplementedAuthorServiceHandler) Delete(context.Context, *connect_go.Request[entpb.DeleteAuthorRequest]) (*connect_go.Response[emptypb.Empty], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("entpb.AuthorService.Delete is not implemented"))
}

func (UnimplementedAuthorServiceHandler) List(context.Context, *connect_go.Request[entpb.ListAuthorRequest]) (*connect_go.Response[entpb.ListAuthorResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("entpb.AuthorService.List is not implemented"))
}

func (UnimplementedAuthorServiceHandler) BatchCreate(context.Context, *connect_go.Request[entpb.BatchCreateAuthorsRequest]) (*connect_go.Response[entpb.BatchCreateAuthorsResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("entpb.AuthorService.BatchCreate is not implemented"))
}

// ComicServiceClient is a client for the entpb.ComicService service.
type ComicServiceClient interface {
	Create(context.Context, *connect_go.Request[entpb.CreateComicRequest]) (*connect_go.Response[entpb.Comic], error)
	Get(context.Context, *connect_go.Request[entpb.GetComicRequest]) (*connect_go.Response[entpb.Comic], error)
	Update(context.Context, *connect_go.Request[entpb.UpdateComicRequest]) (*connect_go.Response[entpb.Comic], error)
	Delete(context.Context, *connect_go.Request[entpb.DeleteComicRequest]) (*connect_go.Response[emptypb.Empty], error)
	List(context.Context, *connect_go.Request[entpb.ListComicRequest]) (*connect_go.Response[entpb.ListComicResponse], error)
	BatchCreate(context.Context, *connect_go.Request[entpb.BatchCreateComicsRequest]) (*connect_go.Response[entpb.BatchCreateComicsResponse], error)
}

// NewComicServiceClient constructs a client for the entpb.ComicService service. By default, it uses
// the Connect protocol with the binary Protobuf Codec, asks for gzipped responses, and sends
// uncompressed requests. To use the gRPC or gRPC-Web protocols, supply the connect.WithGRPC() or
// connect.WithGRPCWeb() options.
//
// The URL supplied here should be the base URL for the Connect or gRPC server (for example,
// http://api.acme.com or https://acme.com/grpc).
func NewComicServiceClient(httpClient connect_go.HTTPClient, baseURL string, opts ...connect_go.ClientOption) ComicServiceClient {
	baseURL = strings.TrimRight(baseURL, "/")
	return &comicServiceClient{
		create: connect_go.NewClient[entpb.CreateComicRequest, entpb.Comic](
			httpClient,
			baseURL+"/entpb.ComicService/Create",
			opts...,
		),
		get: connect_go.NewClient[entpb.GetComicRequest, entpb.Comic](
			httpClient,
			baseURL+"/entpb.ComicService/Get",
			opts...,
		),
		update: connect_go.NewClient[entpb.UpdateComicRequest, entpb.Comic](
			httpClient,
			baseURL+"/entpb.ComicService/Update",
			opts...,
		),
		delete: connect_go.NewClient[entpb.DeleteComicRequest, emptypb.Empty](
			httpClient,
			baseURL+"/entpb.ComicService/Delete",
			opts...,
		),
		list: connect_go.NewClient[entpb.ListComicRequest, entpb.ListComicResponse](
			httpClient,
			baseURL+"/entpb.ComicService/List",
			opts...,
		),
		batchCreate: connect_go.NewClient[entpb.BatchCreateComicsRequest, entpb.BatchCreateComicsResponse](
			httpClient,
			baseURL+"/entpb.ComicService/BatchCreate",
			opts...,
		),
	}
}

// comicServiceClient implements ComicServiceClient.
type comicServiceClient struct {
	create      *connect_go.Client[entpb.CreateComicRequest, entpb.Comic]
	get         *connect_go.Client[entpb.GetComicRequest, entpb.Comic]
	update      *connect_go.Client[entpb.UpdateComicRequest, entpb.Comic]
	delete      *connect_go.Client[entpb.DeleteComicRequest, emptypb.Empty]
	list        *connect_go.Client[entpb.ListComicRequest, entpb.ListComicResponse]
	batchCreate *connect_go.Client[entpb.BatchCreateComicsRequest, entpb.BatchCreateComicsResponse]
}

// Create calls entpb.ComicService.Create.
func (c *comicServiceClient) Create(ctx context.Context, req *connect_go.Request[entpb.CreateComicRequest]) (*connect_go.Response[entpb.Comic], error) {
	return c.create.CallUnary(ctx, req)
}

// Get calls entpb.ComicService.Get.
func (c *comicServiceClient) Get(ctx context.Context, req *connect_go.Request[entpb.GetComicRequest]) (*connect_go.Response[entpb.Comic], error) {
	return c.get.CallUnary(ctx, req)
}

// Update calls entpb.ComicService.Update.
func (c *comicServiceClient) Update(ctx context.Context, req *connect_go.Request[entpb.UpdateComicRequest]) (*connect_go.Response[entpb.Comic], error) {
	return c.update.CallUnary(ctx, req)
}

// Delete calls entpb.ComicService.Delete.
func (c *comicServiceClient) Delete(ctx context.Context, req *connect_go.Request[entpb.DeleteComicRequest]) (*connect_go.Response[emptypb.Empty], error) {
	return c.delete.CallUnary(ctx, req)
}

// List calls entpb.ComicService.List.
func (c *comicServiceClient) List(ctx context.Context, req *connect_go.Request[entpb.ListComicRequest]) (*connect_go.Response[entpb.ListComicResponse], error) {
	return c.list.CallUnary(ctx, req)
}

// BatchCreate calls entpb.ComicService.BatchCreate.
func (c *comicServiceClient) BatchCreate(ctx context.Context, req *connect_go.Request[entpb.BatchCreateComicsRequest]) (*connect_go.Response[entpb.BatchCreateComicsResponse], error) {
	return c.batchCreate.CallUnary(ctx, req)
}

// ComicServiceHandler is an implementation of the entpb.ComicService service.
type ComicServiceHandler interface {
	Create(context.Context, *connect_go.Request[entpb.CreateComicRequest]) (*connect_go.Response[entpb.Comic], error)
	Get(context.Context, *connect_go.Request[entpb.GetComicRequest]) (*connect_go.Response[entpb.Comic], error)
	Update(context.Context, *connect_go.Request[entpb.UpdateComicRequest]) (*connect_go.Response[entpb.Comic], error)
	Delete(context.Context, *connect_go.Request[entpb.DeleteComicRequest]) (*connect_go.Response[emptypb.Empty], error)
	List(context.Context, *connect_go.Request[entpb.ListComicRequest]) (*connect_go.Response[entpb.ListComicResponse], error)
	BatchCreate(context.Context, *connect_go.Request[entpb.BatchCreateComicsRequest]) (*connect_go.Response[entpb.BatchCreateComicsResponse], error)
}

// NewComicServiceHandler builds an HTTP handler from the service implementation. It returns the
// path on which to mount the handler and the handler itself.
//
// By default, handlers support the Connect, gRPC, and gRPC-Web protocols with the binary Protobuf
// and JSON codecs. They also support gzip compression.
func NewComicServiceHandler(svc ComicServiceHandler, opts ...connect_go.HandlerOption) (string, http.Handler) {
	mux := http.NewServeMux()
	mux.Handle("/entpb.ComicService/Create", connect_go.NewUnaryHandler(
		"/entpb.ComicService/Create",
		svc.Create,
		opts...,
	))
	mux.Handle("/entpb.ComicService/Get", connect_go.NewUnaryHandler(
		"/entpb.ComicService/Get",
		svc.Get,
		opts...,
	))
	mux.Handle("/entpb.ComicService/Update", connect_go.NewUnaryHandler(
		"/entpb.ComicService/Update",
		svc.Update,
		opts...,
	))
	mux.Handle("/entpb.ComicService/Delete", connect_go.NewUnaryHandler(
		"/entpb.ComicService/Delete",
		svc.Delete,
		opts...,
	))
	mux.Handle("/entpb.ComicService/List", connect_go.NewUnaryHandler(
		"/entpb.ComicService/List",
		svc.List,
		opts...,
	))
	mux.Handle("/entpb.ComicService/BatchCreate", connect_go.NewUnaryHandler(
		"/entpb.ComicService/BatchCreate",
		svc.BatchCreate,
		opts...,
	))
	return "/entpb.ComicService/", mux
}

// UnimplementedComicServiceHandler returns CodeUnimplemented from all methods.
type UnimplementedComicServiceHandler struct{}

func (UnimplementedComicServiceHandler) Create(context.Context, *connect_go.Request[entpb.CreateComicRequest]) (*connect_go.Response[entpb.Comic], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("entpb.ComicService.Create is not implemented"))
}

func (UnimplementedComicServiceHandler) Get(context.Context, *connect_go.Request[entpb.GetComicRequest]) (*connect_go.Response[entpb.Comic], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("entpb.ComicService.Get is not implemented"))
}

func (UnimplementedComicServiceHandler) Update(context.Context, *connect_go.Request[entpb.UpdateComicRequest]) (*connect_go.Response[entpb.Comic], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("entpb.ComicService.Update is not implemented"))
}

func (UnimplementedComicServiceHandler) Delete(context.Context, *connect_go.Request[entpb.DeleteComicRequest]) (*connect_go.Response[emptypb.Empty], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("entpb.ComicService.Delete is not implemented"))
}

func (UnimplementedComicServiceHandler) List(context.Context, *connect_go.Request[entpb.ListComicRequest]) (*connect_go.Response[entpb.ListComicResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("entpb.ComicService.List is not implemented"))
}

func (UnimplementedComicServiceHandler) BatchCreate(context.Context, *connect_go.Request[entpb.BatchCreateComicsRequest]) (*connect_go.Response[entpb.BatchCreateComicsResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("entpb.ComicService.BatchCreate is not implemented"))
}

// EpisodeServiceClient is a client for the entpb.EpisodeService service.
type EpisodeServiceClient interface {
	Create(context.Context, *connect_go.Request[entpb.CreateEpisodeRequest]) (*connect_go.Response[entpb.Episode], error)
	Get(context.Context, *connect_go.Request[entpb.GetEpisodeRequest]) (*connect_go.Response[entpb.Episode], error)
	Update(context.Context, *connect_go.Request[entpb.UpdateEpisodeRequest]) (*connect_go.Response[entpb.Episode], error)
	Delete(context.Context, *connect_go.Request[entpb.DeleteEpisodeRequest]) (*connect_go.Response[emptypb.Empty], error)
	List(context.Context, *connect_go.Request[entpb.ListEpisodeRequest]) (*connect_go.Response[entpb.ListEpisodeResponse], error)
	BatchCreate(context.Context, *connect_go.Request[entpb.BatchCreateEpisodesRequest]) (*connect_go.Response[entpb.BatchCreateEpisodesResponse], error)
}

// NewEpisodeServiceClient constructs a client for the entpb.EpisodeService service. By default, it
// uses the Connect protocol with the binary Protobuf Codec, asks for gzipped responses, and sends
// uncompressed requests. To use the gRPC or gRPC-Web protocols, supply the connect.WithGRPC() or
// connect.WithGRPCWeb() options.
//
// The URL supplied here should be the base URL for the Connect or gRPC server (for example,
// http://api.acme.com or https://acme.com/grpc).
func NewEpisodeServiceClient(httpClient connect_go.HTTPClient, baseURL string, opts ...connect_go.ClientOption) EpisodeServiceClient {
	baseURL = strings.TrimRight(baseURL, "/")
	return &episodeServiceClient{
		create: connect_go.NewClient[entpb.CreateEpisodeRequest, entpb.Episode](
			httpClient,
			baseURL+"/entpb.EpisodeService/Create",
			opts...,
		),
		get: connect_go.NewClient[entpb.GetEpisodeRequest, entpb.Episode](
			httpClient,
			baseURL+"/entpb.EpisodeService/Get",
			opts...,
		),
		update: connect_go.NewClient[entpb.UpdateEpisodeRequest, entpb.Episode](
			httpClient,
			baseURL+"/entpb.EpisodeService/Update",
			opts...,
		),
		delete: connect_go.NewClient[entpb.DeleteEpisodeRequest, emptypb.Empty](
			httpClient,
			baseURL+"/entpb.EpisodeService/Delete",
			opts...,
		),
		list: connect_go.NewClient[entpb.ListEpisodeRequest, entpb.ListEpisodeResponse](
			httpClient,
			baseURL+"/entpb.EpisodeService/List",
			opts...,
		),
		batchCreate: connect_go.NewClient[entpb.BatchCreateEpisodesRequest, entpb.BatchCreateEpisodesResponse](
			httpClient,
			baseURL+"/entpb.EpisodeService/BatchCreate",
			opts...,
		),
	}
}

// episodeServiceClient implements EpisodeServiceClient.
type episodeServiceClient struct {
	create      *connect_go.Client[entpb.CreateEpisodeRequest, entpb.Episode]
	get         *connect_go.Client[entpb.GetEpisodeRequest, entpb.Episode]
	update      *connect_go.Client[entpb.UpdateEpisodeRequest, entpb.Episode]
	delete      *connect_go.Client[entpb.DeleteEpisodeRequest, emptypb.Empty]
	list        *connect_go.Client[entpb.ListEpisodeRequest, entpb.ListEpisodeResponse]
	batchCreate *connect_go.Client[entpb.BatchCreateEpisodesRequest, entpb.BatchCreateEpisodesResponse]
}

// Create calls entpb.EpisodeService.Create.
func (c *episodeServiceClient) Create(ctx context.Context, req *connect_go.Request[entpb.CreateEpisodeRequest]) (*connect_go.Response[entpb.Episode], error) {
	return c.create.CallUnary(ctx, req)
}

// Get calls entpb.EpisodeService.Get.
func (c *episodeServiceClient) Get(ctx context.Context, req *connect_go.Request[entpb.GetEpisodeRequest]) (*connect_go.Response[entpb.Episode], error) {
	return c.get.CallUnary(ctx, req)
}

// Update calls entpb.EpisodeService.Update.
func (c *episodeServiceClient) Update(ctx context.Context, req *connect_go.Request[entpb.UpdateEpisodeRequest]) (*connect_go.Response[entpb.Episode], error) {
	return c.update.CallUnary(ctx, req)
}

// Delete calls entpb.EpisodeService.Delete.
func (c *episodeServiceClient) Delete(ctx context.Context, req *connect_go.Request[entpb.DeleteEpisodeRequest]) (*connect_go.Response[emptypb.Empty], error) {
	return c.delete.CallUnary(ctx, req)
}

// List calls entpb.EpisodeService.List.
func (c *episodeServiceClient) List(ctx context.Context, req *connect_go.Request[entpb.ListEpisodeRequest]) (*connect_go.Response[entpb.ListEpisodeResponse], error) {
	return c.list.CallUnary(ctx, req)
}

// BatchCreate calls entpb.EpisodeService.BatchCreate.
func (c *episodeServiceClient) BatchCreate(ctx context.Context, req *connect_go.Request[entpb.BatchCreateEpisodesRequest]) (*connect_go.Response[entpb.BatchCreateEpisodesResponse], error) {
	return c.batchCreate.CallUnary(ctx, req)
}

// EpisodeServiceHandler is an implementation of the entpb.EpisodeService service.
type EpisodeServiceHandler interface {
	Create(context.Context, *connect_go.Request[entpb.CreateEpisodeRequest]) (*connect_go.Response[entpb.Episode], error)
	Get(context.Context, *connect_go.Request[entpb.GetEpisodeRequest]) (*connect_go.Response[entpb.Episode], error)
	Update(context.Context, *connect_go.Request[entpb.UpdateEpisodeRequest]) (*connect_go.Response[entpb.Episode], error)
	Delete(context.Context, *connect_go.Request[entpb.DeleteEpisodeRequest]) (*connect_go.Response[emptypb.Empty], error)
	List(context.Context, *connect_go.Request[entpb.ListEpisodeRequest]) (*connect_go.Response[entpb.ListEpisodeResponse], error)
	BatchCreate(context.Context, *connect_go.Request[entpb.BatchCreateEpisodesRequest]) (*connect_go.Response[entpb.BatchCreateEpisodesResponse], error)
}

// NewEpisodeServiceHandler builds an HTTP handler from the service implementation. It returns the
// path on which to mount the handler and the handler itself.
//
// By default, handlers support the Connect, gRPC, and gRPC-Web protocols with the binary Protobuf
// and JSON codecs. They also support gzip compression.
func NewEpisodeServiceHandler(svc EpisodeServiceHandler, opts ...connect_go.HandlerOption) (string, http.Handler) {
	mux := http.NewServeMux()
	mux.Handle("/entpb.EpisodeService/Create", connect_go.NewUnaryHandler(
		"/entpb.EpisodeService/Create",
		svc.Create,
		opts...,
	))
	mux.Handle("/entpb.EpisodeService/Get", connect_go.NewUnaryHandler(
		"/entpb.EpisodeService/Get",
		svc.Get,
		opts...,
	))
	mux.Handle("/entpb.EpisodeService/Update", connect_go.NewUnaryHandler(
		"/entpb.EpisodeService/Update",
		svc.Update,
		opts...,
	))
	mux.Handle("/entpb.EpisodeService/Delete", connect_go.NewUnaryHandler(
		"/entpb.EpisodeService/Delete",
		svc.Delete,
		opts...,
	))
	mux.Handle("/entpb.EpisodeService/List", connect_go.NewUnaryHandler(
		"/entpb.EpisodeService/List",
		svc.List,
		opts...,
	))
	mux.Handle("/entpb.EpisodeService/BatchCreate", connect_go.NewUnaryHandler(
		"/entpb.EpisodeService/BatchCreate",
		svc.BatchCreate,
		opts...,
	))
	return "/entpb.EpisodeService/", mux
}

// UnimplementedEpisodeServiceHandler returns CodeUnimplemented from all methods.
type UnimplementedEpisodeServiceHandler struct{}

func (UnimplementedEpisodeServiceHandler) Create(context.Context, *connect_go.Request[entpb.CreateEpisodeRequest]) (*connect_go.Response[entpb.Episode], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("entpb.EpisodeService.Create is not implemented"))
}

func (UnimplementedEpisodeServiceHandler) Get(context.Context, *connect_go.Request[entpb.GetEpisodeRequest]) (*connect_go.Response[entpb.Episode], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("entpb.EpisodeService.Get is not implemented"))
}

func (UnimplementedEpisodeServiceHandler) Update(context.Context, *connect_go.Request[entpb.UpdateEpisodeRequest]) (*connect_go.Response[entpb.Episode], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("entpb.EpisodeService.Update is not implemented"))
}

func (UnimplementedEpisodeServiceHandler) Delete(context.Context, *connect_go.Request[entpb.DeleteEpisodeRequest]) (*connect_go.Response[emptypb.Empty], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("entpb.EpisodeService.Delete is not implemented"))
}

func (UnimplementedEpisodeServiceHandler) List(context.Context, *connect_go.Request[entpb.ListEpisodeRequest]) (*connect_go.Response[entpb.ListEpisodeResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("entpb.EpisodeService.List is not implemented"))
}

func (UnimplementedEpisodeServiceHandler) BatchCreate(context.Context, *connect_go.Request[entpb.BatchCreateEpisodesRequest]) (*connect_go.Response[entpb.BatchCreateEpisodesResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("entpb.EpisodeService.BatchCreate is not implemented"))
}

// MagazineServiceClient is a client for the entpb.MagazineService service.
type MagazineServiceClient interface {
	Create(context.Context, *connect_go.Request[entpb.CreateMagazineRequest]) (*connect_go.Response[entpb.Magazine], error)
	Get(context.Context, *connect_go.Request[entpb.GetMagazineRequest]) (*connect_go.Response[entpb.Magazine], error)
	Update(context.Context, *connect_go.Request[entpb.UpdateMagazineRequest]) (*connect_go.Response[entpb.Magazine], error)
	Delete(context.Context, *connect_go.Request[entpb.DeleteMagazineRequest]) (*connect_go.Response[emptypb.Empty], error)
	List(context.Context, *connect_go.Request[entpb.ListMagazineRequest]) (*connect_go.Response[entpb.ListMagazineResponse], error)
	BatchCreate(context.Context, *connect_go.Request[entpb.BatchCreateMagazinesRequest]) (*connect_go.Response[entpb.BatchCreateMagazinesResponse], error)
}

// NewMagazineServiceClient constructs a client for the entpb.MagazineService service. By default,
// it uses the Connect protocol with the binary Protobuf Codec, asks for gzipped responses, and
// sends uncompressed requests. To use the gRPC or gRPC-Web protocols, supply the connect.WithGRPC()
// or connect.WithGRPCWeb() options.
//
// The URL supplied here should be the base URL for the Connect or gRPC server (for example,
// http://api.acme.com or https://acme.com/grpc).
func NewMagazineServiceClient(httpClient connect_go.HTTPClient, baseURL string, opts ...connect_go.ClientOption) MagazineServiceClient {
	baseURL = strings.TrimRight(baseURL, "/")
	return &magazineServiceClient{
		create: connect_go.NewClient[entpb.CreateMagazineRequest, entpb.Magazine](
			httpClient,
			baseURL+"/entpb.MagazineService/Create",
			opts...,
		),
		get: connect_go.NewClient[entpb.GetMagazineRequest, entpb.Magazine](
			httpClient,
			baseURL+"/entpb.MagazineService/Get",
			opts...,
		),
		update: connect_go.NewClient[entpb.UpdateMagazineRequest, entpb.Magazine](
			httpClient,
			baseURL+"/entpb.MagazineService/Update",
			opts...,
		),
		delete: connect_go.NewClient[entpb.DeleteMagazineRequest, emptypb.Empty](
			httpClient,
			baseURL+"/entpb.MagazineService/Delete",
			opts...,
		),
		list: connect_go.NewClient[entpb.ListMagazineRequest, entpb.ListMagazineResponse](
			httpClient,
			baseURL+"/entpb.MagazineService/List",
			opts...,
		),
		batchCreate: connect_go.NewClient[entpb.BatchCreateMagazinesRequest, entpb.BatchCreateMagazinesResponse](
			httpClient,
			baseURL+"/entpb.MagazineService/BatchCreate",
			opts...,
		),
	}
}

// magazineServiceClient implements MagazineServiceClient.
type magazineServiceClient struct {
	create      *connect_go.Client[entpb.CreateMagazineRequest, entpb.Magazine]
	get         *connect_go.Client[entpb.GetMagazineRequest, entpb.Magazine]
	update      *connect_go.Client[entpb.UpdateMagazineRequest, entpb.Magazine]
	delete      *connect_go.Client[entpb.DeleteMagazineRequest, emptypb.Empty]
	list        *connect_go.Client[entpb.ListMagazineRequest, entpb.ListMagazineResponse]
	batchCreate *connect_go.Client[entpb.BatchCreateMagazinesRequest, entpb.BatchCreateMagazinesResponse]
}

// Create calls entpb.MagazineService.Create.
func (c *magazineServiceClient) Create(ctx context.Context, req *connect_go.Request[entpb.CreateMagazineRequest]) (*connect_go.Response[entpb.Magazine], error) {
	return c.create.CallUnary(ctx, req)
}

// Get calls entpb.MagazineService.Get.
func (c *magazineServiceClient) Get(ctx context.Context, req *connect_go.Request[entpb.GetMagazineRequest]) (*connect_go.Response[entpb.Magazine], error) {
	return c.get.CallUnary(ctx, req)
}

// Update calls entpb.MagazineService.Update.
func (c *magazineServiceClient) Update(ctx context.Context, req *connect_go.Request[entpb.UpdateMagazineRequest]) (*connect_go.Response[entpb.Magazine], error) {
	return c.update.CallUnary(ctx, req)
}

// Delete calls entpb.MagazineService.Delete.
func (c *magazineServiceClient) Delete(ctx context.Context, req *connect_go.Request[entpb.DeleteMagazineRequest]) (*connect_go.Response[emptypb.Empty], error) {
	return c.delete.CallUnary(ctx, req)
}

// List calls entpb.MagazineService.List.
func (c *magazineServiceClient) List(ctx context.Context, req *connect_go.Request[entpb.ListMagazineRequest]) (*connect_go.Response[entpb.ListMagazineResponse], error) {
	return c.list.CallUnary(ctx, req)
}

// BatchCreate calls entpb.MagazineService.BatchCreate.
func (c *magazineServiceClient) BatchCreate(ctx context.Context, req *connect_go.Request[entpb.BatchCreateMagazinesRequest]) (*connect_go.Response[entpb.BatchCreateMagazinesResponse], error) {
	return c.batchCreate.CallUnary(ctx, req)
}

// MagazineServiceHandler is an implementation of the entpb.MagazineService service.
type MagazineServiceHandler interface {
	Create(context.Context, *connect_go.Request[entpb.CreateMagazineRequest]) (*connect_go.Response[entpb.Magazine], error)
	Get(context.Context, *connect_go.Request[entpb.GetMagazineRequest]) (*connect_go.Response[entpb.Magazine], error)
	Update(context.Context, *connect_go.Request[entpb.UpdateMagazineRequest]) (*connect_go.Response[entpb.Magazine], error)
	Delete(context.Context, *connect_go.Request[entpb.DeleteMagazineRequest]) (*connect_go.Response[emptypb.Empty], error)
	List(context.Context, *connect_go.Request[entpb.ListMagazineRequest]) (*connect_go.Response[entpb.ListMagazineResponse], error)
	BatchCreate(context.Context, *connect_go.Request[entpb.BatchCreateMagazinesRequest]) (*connect_go.Response[entpb.BatchCreateMagazinesResponse], error)
}

// NewMagazineServiceHandler builds an HTTP handler from the service implementation. It returns the
// path on which to mount the handler and the handler itself.
//
// By default, handlers support the Connect, gRPC, and gRPC-Web protocols with the binary Protobuf
// and JSON codecs. They also support gzip compression.
func NewMagazineServiceHandler(svc MagazineServiceHandler, opts ...connect_go.HandlerOption) (string, http.Handler) {
	mux := http.NewServeMux()
	mux.Handle("/entpb.MagazineService/Create", connect_go.NewUnaryHandler(
		"/entpb.MagazineService/Create",
		svc.Create,
		opts...,
	))
	mux.Handle("/entpb.MagazineService/Get", connect_go.NewUnaryHandler(
		"/entpb.MagazineService/Get",
		svc.Get,
		opts...,
	))
	mux.Handle("/entpb.MagazineService/Update", connect_go.NewUnaryHandler(
		"/entpb.MagazineService/Update",
		svc.Update,
		opts...,
	))
	mux.Handle("/entpb.MagazineService/Delete", connect_go.NewUnaryHandler(
		"/entpb.MagazineService/Delete",
		svc.Delete,
		opts...,
	))
	mux.Handle("/entpb.MagazineService/List", connect_go.NewUnaryHandler(
		"/entpb.MagazineService/List",
		svc.List,
		opts...,
	))
	mux.Handle("/entpb.MagazineService/BatchCreate", connect_go.NewUnaryHandler(
		"/entpb.MagazineService/BatchCreate",
		svc.BatchCreate,
		opts...,
	))
	return "/entpb.MagazineService/", mux
}

// UnimplementedMagazineServiceHandler returns CodeUnimplemented from all methods.
type UnimplementedMagazineServiceHandler struct{}

func (UnimplementedMagazineServiceHandler) Create(context.Context, *connect_go.Request[entpb.CreateMagazineRequest]) (*connect_go.Response[entpb.Magazine], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("entpb.MagazineService.Create is not implemented"))
}

func (UnimplementedMagazineServiceHandler) Get(context.Context, *connect_go.Request[entpb.GetMagazineRequest]) (*connect_go.Response[entpb.Magazine], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("entpb.MagazineService.Get is not implemented"))
}

func (UnimplementedMagazineServiceHandler) Update(context.Context, *connect_go.Request[entpb.UpdateMagazineRequest]) (*connect_go.Response[entpb.Magazine], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("entpb.MagazineService.Update is not implemented"))
}

func (UnimplementedMagazineServiceHandler) Delete(context.Context, *connect_go.Request[entpb.DeleteMagazineRequest]) (*connect_go.Response[emptypb.Empty], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("entpb.MagazineService.Delete is not implemented"))
}

func (UnimplementedMagazineServiceHandler) List(context.Context, *connect_go.Request[entpb.ListMagazineRequest]) (*connect_go.Response[entpb.ListMagazineResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("entpb.MagazineService.List is not implemented"))
}

func (UnimplementedMagazineServiceHandler) BatchCreate(context.Context, *connect_go.Request[entpb.BatchCreateMagazinesRequest]) (*connect_go.Response[entpb.BatchCreateMagazinesResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("entpb.MagazineService.BatchCreate is not implemented"))
}

// TagServiceClient is a client for the entpb.TagService service.
type TagServiceClient interface {
	Create(context.Context, *connect_go.Request[entpb.CreateTagRequest]) (*connect_go.Response[entpb.Tag], error)
	Get(context.Context, *connect_go.Request[entpb.GetTagRequest]) (*connect_go.Response[entpb.Tag], error)
	Update(context.Context, *connect_go.Request[entpb.UpdateTagRequest]) (*connect_go.Response[entpb.Tag], error)
	Delete(context.Context, *connect_go.Request[entpb.DeleteTagRequest]) (*connect_go.Response[emptypb.Empty], error)
	List(context.Context, *connect_go.Request[entpb.ListTagRequest]) (*connect_go.Response[entpb.ListTagResponse], error)
	BatchCreate(context.Context, *connect_go.Request[entpb.BatchCreateTagsRequest]) (*connect_go.Response[entpb.BatchCreateTagsResponse], error)
}

// NewTagServiceClient constructs a client for the entpb.TagService service. By default, it uses the
// Connect protocol with the binary Protobuf Codec, asks for gzipped responses, and sends
// uncompressed requests. To use the gRPC or gRPC-Web protocols, supply the connect.WithGRPC() or
// connect.WithGRPCWeb() options.
//
// The URL supplied here should be the base URL for the Connect or gRPC server (for example,
// http://api.acme.com or https://acme.com/grpc).
func NewTagServiceClient(httpClient connect_go.HTTPClient, baseURL string, opts ...connect_go.ClientOption) TagServiceClient {
	baseURL = strings.TrimRight(baseURL, "/")
	return &tagServiceClient{
		create: connect_go.NewClient[entpb.CreateTagRequest, entpb.Tag](
			httpClient,
			baseURL+"/entpb.TagService/Create",
			opts...,
		),
		get: connect_go.NewClient[entpb.GetTagRequest, entpb.Tag](
			httpClient,
			baseURL+"/entpb.TagService/Get",
			opts...,
		),
		update: connect_go.NewClient[entpb.UpdateTagRequest, entpb.Tag](
			httpClient,
			baseURL+"/entpb.TagService/Update",
			opts...,
		),
		delete: connect_go.NewClient[entpb.DeleteTagRequest, emptypb.Empty](
			httpClient,
			baseURL+"/entpb.TagService/Delete",
			opts...,
		),
		list: connect_go.NewClient[entpb.ListTagRequest, entpb.ListTagResponse](
			httpClient,
			baseURL+"/entpb.TagService/List",
			opts...,
		),
		batchCreate: connect_go.NewClient[entpb.BatchCreateTagsRequest, entpb.BatchCreateTagsResponse](
			httpClient,
			baseURL+"/entpb.TagService/BatchCreate",
			opts...,
		),
	}
}

// tagServiceClient implements TagServiceClient.
type tagServiceClient struct {
	create      *connect_go.Client[entpb.CreateTagRequest, entpb.Tag]
	get         *connect_go.Client[entpb.GetTagRequest, entpb.Tag]
	update      *connect_go.Client[entpb.UpdateTagRequest, entpb.Tag]
	delete      *connect_go.Client[entpb.DeleteTagRequest, emptypb.Empty]
	list        *connect_go.Client[entpb.ListTagRequest, entpb.ListTagResponse]
	batchCreate *connect_go.Client[entpb.BatchCreateTagsRequest, entpb.BatchCreateTagsResponse]
}

// Create calls entpb.TagService.Create.
func (c *tagServiceClient) Create(ctx context.Context, req *connect_go.Request[entpb.CreateTagRequest]) (*connect_go.Response[entpb.Tag], error) {
	return c.create.CallUnary(ctx, req)
}

// Get calls entpb.TagService.Get.
func (c *tagServiceClient) Get(ctx context.Context, req *connect_go.Request[entpb.GetTagRequest]) (*connect_go.Response[entpb.Tag], error) {
	return c.get.CallUnary(ctx, req)
}

// Update calls entpb.TagService.Update.
func (c *tagServiceClient) Update(ctx context.Context, req *connect_go.Request[entpb.UpdateTagRequest]) (*connect_go.Response[entpb.Tag], error) {
	return c.update.CallUnary(ctx, req)
}

// Delete calls entpb.TagService.Delete.
func (c *tagServiceClient) Delete(ctx context.Context, req *connect_go.Request[entpb.DeleteTagRequest]) (*connect_go.Response[emptypb.Empty], error) {
	return c.delete.CallUnary(ctx, req)
}

// List calls entpb.TagService.List.
func (c *tagServiceClient) List(ctx context.Context, req *connect_go.Request[entpb.ListTagRequest]) (*connect_go.Response[entpb.ListTagResponse], error) {
	return c.list.CallUnary(ctx, req)
}

// BatchCreate calls entpb.TagService.BatchCreate.
func (c *tagServiceClient) BatchCreate(ctx context.Context, req *connect_go.Request[entpb.BatchCreateTagsRequest]) (*connect_go.Response[entpb.BatchCreateTagsResponse], error) {
	return c.batchCreate.CallUnary(ctx, req)
}

// TagServiceHandler is an implementation of the entpb.TagService service.
type TagServiceHandler interface {
	Create(context.Context, *connect_go.Request[entpb.CreateTagRequest]) (*connect_go.Response[entpb.Tag], error)
	Get(context.Context, *connect_go.Request[entpb.GetTagRequest]) (*connect_go.Response[entpb.Tag], error)
	Update(context.Context, *connect_go.Request[entpb.UpdateTagRequest]) (*connect_go.Response[entpb.Tag], error)
	Delete(context.Context, *connect_go.Request[entpb.DeleteTagRequest]) (*connect_go.Response[emptypb.Empty], error)
	List(context.Context, *connect_go.Request[entpb.ListTagRequest]) (*connect_go.Response[entpb.ListTagResponse], error)
	BatchCreate(context.Context, *connect_go.Request[entpb.BatchCreateTagsRequest]) (*connect_go.Response[entpb.BatchCreateTagsResponse], error)
}

// NewTagServiceHandler builds an HTTP handler from the service implementation. It returns the path
// on which to mount the handler and the handler itself.
//
// By default, handlers support the Connect, gRPC, and gRPC-Web protocols with the binary Protobuf
// and JSON codecs. They also support gzip compression.
func NewTagServiceHandler(svc TagServiceHandler, opts ...connect_go.HandlerOption) (string, http.Handler) {
	mux := http.NewServeMux()
	mux.Handle("/entpb.TagService/Create", connect_go.NewUnaryHandler(
		"/entpb.TagService/Create",
		svc.Create,
		opts...,
	))
	mux.Handle("/entpb.TagService/Get", connect_go.NewUnaryHandler(
		"/entpb.TagService/Get",
		svc.Get,
		opts...,
	))
	mux.Handle("/entpb.TagService/Update", connect_go.NewUnaryHandler(
		"/entpb.TagService/Update",
		svc.Update,
		opts...,
	))
	mux.Handle("/entpb.TagService/Delete", connect_go.NewUnaryHandler(
		"/entpb.TagService/Delete",
		svc.Delete,
		opts...,
	))
	mux.Handle("/entpb.TagService/List", connect_go.NewUnaryHandler(
		"/entpb.TagService/List",
		svc.List,
		opts...,
	))
	mux.Handle("/entpb.TagService/BatchCreate", connect_go.NewUnaryHandler(
		"/entpb.TagService/BatchCreate",
		svc.BatchCreate,
		opts...,
	))
	return "/entpb.TagService/", mux
}

// UnimplementedTagServiceHandler returns CodeUnimplemented from all methods.
type UnimplementedTagServiceHandler struct{}

func (UnimplementedTagServiceHandler) Create(context.Context, *connect_go.Request[entpb.CreateTagRequest]) (*connect_go.Response[entpb.Tag], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("entpb.TagService.Create is not implemented"))
}

func (UnimplementedTagServiceHandler) Get(context.Context, *connect_go.Request[entpb.GetTagRequest]) (*connect_go.Response[entpb.Tag], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("entpb.TagService.Get is not implemented"))
}

func (UnimplementedTagServiceHandler) Update(context.Context, *connect_go.Request[entpb.UpdateTagRequest]) (*connect_go.Response[entpb.Tag], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("entpb.TagService.Update is not implemented"))
}

func (UnimplementedTagServiceHandler) Delete(context.Context, *connect_go.Request[entpb.DeleteTagRequest]) (*connect_go.Response[emptypb.Empty], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("entpb.TagService.Delete is not implemented"))
}

func (UnimplementedTagServiceHandler) List(context.Context, *connect_go.Request[entpb.ListTagRequest]) (*connect_go.Response[entpb.ListTagResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("entpb.TagService.List is not implemented"))
}

func (UnimplementedTagServiceHandler) BatchCreate(context.Context, *connect_go.Request[entpb.BatchCreateTagsRequest]) (*connect_go.Response[entpb.BatchCreateTagsResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("entpb.TagService.BatchCreate is not implemented"))
}
