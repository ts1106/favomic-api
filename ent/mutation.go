// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"github.com/google/uuid"
	"github.com/ts1106/favomic-api/ent/author"
	"github.com/ts1106/favomic-api/ent/comic"
	"github.com/ts1106/favomic-api/ent/episode"
	"github.com/ts1106/favomic-api/ent/magazine"
	"github.com/ts1106/favomic-api/ent/predicate"
	"github.com/ts1106/favomic-api/ent/tag"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAuthor   = "Author"
	TypeComic    = "Comic"
	TypeEpisode  = "Episode"
	TypeMagazine = "Magazine"
	TypeTag      = "Tag"
)

// AuthorMutation represents an operation that mutates the Author nodes in the graph.
type AuthorMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	name          *string
	clearedFields map[string]struct{}
	comics        map[uuid.UUID]struct{}
	removedcomics map[uuid.UUID]struct{}
	clearedcomics bool
	done          bool
	oldValue      func(context.Context) (*Author, error)
	predicates    []predicate.Author
}

var _ ent.Mutation = (*AuthorMutation)(nil)

// authorOption allows management of the mutation configuration using functional options.
type authorOption func(*AuthorMutation)

// newAuthorMutation creates new mutation for the Author entity.
func newAuthorMutation(c config, op Op, opts ...authorOption) *AuthorMutation {
	m := &AuthorMutation{
		config:        c,
		op:            op,
		typ:           TypeAuthor,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAuthorID sets the ID field of the mutation.
func withAuthorID(id uuid.UUID) authorOption {
	return func(m *AuthorMutation) {
		var (
			err   error
			once  sync.Once
			value *Author
		)
		m.oldValue = func(ctx context.Context) (*Author, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Author.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAuthor sets the old Author of the mutation.
func withAuthor(node *Author) authorOption {
	return func(m *AuthorMutation) {
		m.oldValue = func(context.Context) (*Author, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AuthorMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AuthorMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Author entities.
func (m *AuthorMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AuthorMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AuthorMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Author.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *AuthorMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AuthorMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Author entity.
// If the Author object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthorMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AuthorMutation) ResetName() {
	m.name = nil
}

// AddComicIDs adds the "comics" edge to the Comic entity by ids.
func (m *AuthorMutation) AddComicIDs(ids ...uuid.UUID) {
	if m.comics == nil {
		m.comics = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.comics[ids[i]] = struct{}{}
	}
}

// ClearComics clears the "comics" edge to the Comic entity.
func (m *AuthorMutation) ClearComics() {
	m.clearedcomics = true
}

// ComicsCleared reports if the "comics" edge to the Comic entity was cleared.
func (m *AuthorMutation) ComicsCleared() bool {
	return m.clearedcomics
}

// RemoveComicIDs removes the "comics" edge to the Comic entity by IDs.
func (m *AuthorMutation) RemoveComicIDs(ids ...uuid.UUID) {
	if m.removedcomics == nil {
		m.removedcomics = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.comics, ids[i])
		m.removedcomics[ids[i]] = struct{}{}
	}
}

// RemovedComics returns the removed IDs of the "comics" edge to the Comic entity.
func (m *AuthorMutation) RemovedComicsIDs() (ids []uuid.UUID) {
	for id := range m.removedcomics {
		ids = append(ids, id)
	}
	return
}

// ComicsIDs returns the "comics" edge IDs in the mutation.
func (m *AuthorMutation) ComicsIDs() (ids []uuid.UUID) {
	for id := range m.comics {
		ids = append(ids, id)
	}
	return
}

// ResetComics resets all changes to the "comics" edge.
func (m *AuthorMutation) ResetComics() {
	m.comics = nil
	m.clearedcomics = false
	m.removedcomics = nil
}

// Where appends a list predicates to the AuthorMutation builder.
func (m *AuthorMutation) Where(ps ...predicate.Author) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AuthorMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Author).
func (m *AuthorMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AuthorMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, author.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AuthorMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case author.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AuthorMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case author.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Author field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthorMutation) SetField(name string, value ent.Value) error {
	switch name {
	case author.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Author field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AuthorMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AuthorMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthorMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Author numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AuthorMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AuthorMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AuthorMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Author nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AuthorMutation) ResetField(name string) error {
	switch name {
	case author.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Author field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AuthorMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.comics != nil {
		edges = append(edges, author.EdgeComics)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AuthorMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case author.EdgeComics:
		ids := make([]ent.Value, 0, len(m.comics))
		for id := range m.comics {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AuthorMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedcomics != nil {
		edges = append(edges, author.EdgeComics)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AuthorMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case author.EdgeComics:
		ids := make([]ent.Value, 0, len(m.removedcomics))
		for id := range m.removedcomics {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AuthorMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcomics {
		edges = append(edges, author.EdgeComics)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AuthorMutation) EdgeCleared(name string) bool {
	switch name {
	case author.EdgeComics:
		return m.clearedcomics
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AuthorMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Author unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AuthorMutation) ResetEdge(name string) error {
	switch name {
	case author.EdgeComics:
		m.ResetComics()
		return nil
	}
	return fmt.Errorf("unknown Author edge %s", name)
}

// ComicMutation represents an operation that mutates the Comic nodes in the graph.
type ComicMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	title           *string
	clearedFields   map[string]struct{}
	author          *uuid.UUID
	clearedauthor   bool
	magazine        *uuid.UUID
	clearedmagazine bool
	tags            map[uuid.UUID]struct{}
	removedtags     map[uuid.UUID]struct{}
	clearedtags     bool
	episodes        map[uuid.UUID]struct{}
	removedepisodes map[uuid.UUID]struct{}
	clearedepisodes bool
	done            bool
	oldValue        func(context.Context) (*Comic, error)
	predicates      []predicate.Comic
}

var _ ent.Mutation = (*ComicMutation)(nil)

// comicOption allows management of the mutation configuration using functional options.
type comicOption func(*ComicMutation)

// newComicMutation creates new mutation for the Comic entity.
func newComicMutation(c config, op Op, opts ...comicOption) *ComicMutation {
	m := &ComicMutation{
		config:        c,
		op:            op,
		typ:           TypeComic,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withComicID sets the ID field of the mutation.
func withComicID(id uuid.UUID) comicOption {
	return func(m *ComicMutation) {
		var (
			err   error
			once  sync.Once
			value *Comic
		)
		m.oldValue = func(ctx context.Context) (*Comic, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Comic.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withComic sets the old Comic of the mutation.
func withComic(node *Comic) comicOption {
	return func(m *ComicMutation) {
		m.oldValue = func(context.Context) (*Comic, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ComicMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ComicMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Comic entities.
func (m *ComicMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ComicMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ComicMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Comic.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTitle sets the "title" field.
func (m *ComicMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *ComicMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Comic entity.
// If the Comic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ComicMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *ComicMutation) ResetTitle() {
	m.title = nil
}

// SetAuthorID sets the "author_id" field.
func (m *ComicMutation) SetAuthorID(u uuid.UUID) {
	m.author = &u
}

// AuthorID returns the value of the "author_id" field in the mutation.
func (m *ComicMutation) AuthorID() (r uuid.UUID, exists bool) {
	v := m.author
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthorID returns the old "author_id" field's value of the Comic entity.
// If the Comic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ComicMutation) OldAuthorID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthorID: %w", err)
	}
	return oldValue.AuthorID, nil
}

// ResetAuthorID resets all changes to the "author_id" field.
func (m *ComicMutation) ResetAuthorID() {
	m.author = nil
}

// SetMagazineID sets the "magazine_id" field.
func (m *ComicMutation) SetMagazineID(u uuid.UUID) {
	m.magazine = &u
}

// MagazineID returns the value of the "magazine_id" field in the mutation.
func (m *ComicMutation) MagazineID() (r uuid.UUID, exists bool) {
	v := m.magazine
	if v == nil {
		return
	}
	return *v, true
}

// OldMagazineID returns the old "magazine_id" field's value of the Comic entity.
// If the Comic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ComicMutation) OldMagazineID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMagazineID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMagazineID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMagazineID: %w", err)
	}
	return oldValue.MagazineID, nil
}

// ResetMagazineID resets all changes to the "magazine_id" field.
func (m *ComicMutation) ResetMagazineID() {
	m.magazine = nil
}

// ClearAuthor clears the "author" edge to the Author entity.
func (m *ComicMutation) ClearAuthor() {
	m.clearedauthor = true
}

// AuthorCleared reports if the "author" edge to the Author entity was cleared.
func (m *ComicMutation) AuthorCleared() bool {
	return m.clearedauthor
}

// AuthorIDs returns the "author" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AuthorID instead. It exists only for internal usage by the builders.
func (m *ComicMutation) AuthorIDs() (ids []uuid.UUID) {
	if id := m.author; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAuthor resets all changes to the "author" edge.
func (m *ComicMutation) ResetAuthor() {
	m.author = nil
	m.clearedauthor = false
}

// ClearMagazine clears the "magazine" edge to the Magazine entity.
func (m *ComicMutation) ClearMagazine() {
	m.clearedmagazine = true
}

// MagazineCleared reports if the "magazine" edge to the Magazine entity was cleared.
func (m *ComicMutation) MagazineCleared() bool {
	return m.clearedmagazine
}

// MagazineIDs returns the "magazine" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MagazineID instead. It exists only for internal usage by the builders.
func (m *ComicMutation) MagazineIDs() (ids []uuid.UUID) {
	if id := m.magazine; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMagazine resets all changes to the "magazine" edge.
func (m *ComicMutation) ResetMagazine() {
	m.magazine = nil
	m.clearedmagazine = false
}

// AddTagIDs adds the "tags" edge to the Tag entity by ids.
func (m *ComicMutation) AddTagIDs(ids ...uuid.UUID) {
	if m.tags == nil {
		m.tags = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.tags[ids[i]] = struct{}{}
	}
}

// ClearTags clears the "tags" edge to the Tag entity.
func (m *ComicMutation) ClearTags() {
	m.clearedtags = true
}

// TagsCleared reports if the "tags" edge to the Tag entity was cleared.
func (m *ComicMutation) TagsCleared() bool {
	return m.clearedtags
}

// RemoveTagIDs removes the "tags" edge to the Tag entity by IDs.
func (m *ComicMutation) RemoveTagIDs(ids ...uuid.UUID) {
	if m.removedtags == nil {
		m.removedtags = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.tags, ids[i])
		m.removedtags[ids[i]] = struct{}{}
	}
}

// RemovedTags returns the removed IDs of the "tags" edge to the Tag entity.
func (m *ComicMutation) RemovedTagsIDs() (ids []uuid.UUID) {
	for id := range m.removedtags {
		ids = append(ids, id)
	}
	return
}

// TagsIDs returns the "tags" edge IDs in the mutation.
func (m *ComicMutation) TagsIDs() (ids []uuid.UUID) {
	for id := range m.tags {
		ids = append(ids, id)
	}
	return
}

// ResetTags resets all changes to the "tags" edge.
func (m *ComicMutation) ResetTags() {
	m.tags = nil
	m.clearedtags = false
	m.removedtags = nil
}

// AddEpisodeIDs adds the "episodes" edge to the Episode entity by ids.
func (m *ComicMutation) AddEpisodeIDs(ids ...uuid.UUID) {
	if m.episodes == nil {
		m.episodes = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.episodes[ids[i]] = struct{}{}
	}
}

// ClearEpisodes clears the "episodes" edge to the Episode entity.
func (m *ComicMutation) ClearEpisodes() {
	m.clearedepisodes = true
}

// EpisodesCleared reports if the "episodes" edge to the Episode entity was cleared.
func (m *ComicMutation) EpisodesCleared() bool {
	return m.clearedepisodes
}

// RemoveEpisodeIDs removes the "episodes" edge to the Episode entity by IDs.
func (m *ComicMutation) RemoveEpisodeIDs(ids ...uuid.UUID) {
	if m.removedepisodes == nil {
		m.removedepisodes = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.episodes, ids[i])
		m.removedepisodes[ids[i]] = struct{}{}
	}
}

// RemovedEpisodes returns the removed IDs of the "episodes" edge to the Episode entity.
func (m *ComicMutation) RemovedEpisodesIDs() (ids []uuid.UUID) {
	for id := range m.removedepisodes {
		ids = append(ids, id)
	}
	return
}

// EpisodesIDs returns the "episodes" edge IDs in the mutation.
func (m *ComicMutation) EpisodesIDs() (ids []uuid.UUID) {
	for id := range m.episodes {
		ids = append(ids, id)
	}
	return
}

// ResetEpisodes resets all changes to the "episodes" edge.
func (m *ComicMutation) ResetEpisodes() {
	m.episodes = nil
	m.clearedepisodes = false
	m.removedepisodes = nil
}

// Where appends a list predicates to the ComicMutation builder.
func (m *ComicMutation) Where(ps ...predicate.Comic) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ComicMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Comic).
func (m *ComicMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ComicMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.title != nil {
		fields = append(fields, comic.FieldTitle)
	}
	if m.author != nil {
		fields = append(fields, comic.FieldAuthorID)
	}
	if m.magazine != nil {
		fields = append(fields, comic.FieldMagazineID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ComicMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case comic.FieldTitle:
		return m.Title()
	case comic.FieldAuthorID:
		return m.AuthorID()
	case comic.FieldMagazineID:
		return m.MagazineID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ComicMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case comic.FieldTitle:
		return m.OldTitle(ctx)
	case comic.FieldAuthorID:
		return m.OldAuthorID(ctx)
	case comic.FieldMagazineID:
		return m.OldMagazineID(ctx)
	}
	return nil, fmt.Errorf("unknown Comic field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ComicMutation) SetField(name string, value ent.Value) error {
	switch name {
	case comic.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case comic.FieldAuthorID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthorID(v)
		return nil
	case comic.FieldMagazineID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMagazineID(v)
		return nil
	}
	return fmt.Errorf("unknown Comic field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ComicMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ComicMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ComicMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Comic numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ComicMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ComicMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ComicMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Comic nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ComicMutation) ResetField(name string) error {
	switch name {
	case comic.FieldTitle:
		m.ResetTitle()
		return nil
	case comic.FieldAuthorID:
		m.ResetAuthorID()
		return nil
	case comic.FieldMagazineID:
		m.ResetMagazineID()
		return nil
	}
	return fmt.Errorf("unknown Comic field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ComicMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.author != nil {
		edges = append(edges, comic.EdgeAuthor)
	}
	if m.magazine != nil {
		edges = append(edges, comic.EdgeMagazine)
	}
	if m.tags != nil {
		edges = append(edges, comic.EdgeTags)
	}
	if m.episodes != nil {
		edges = append(edges, comic.EdgeEpisodes)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ComicMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case comic.EdgeAuthor:
		if id := m.author; id != nil {
			return []ent.Value{*id}
		}
	case comic.EdgeMagazine:
		if id := m.magazine; id != nil {
			return []ent.Value{*id}
		}
	case comic.EdgeTags:
		ids := make([]ent.Value, 0, len(m.tags))
		for id := range m.tags {
			ids = append(ids, id)
		}
		return ids
	case comic.EdgeEpisodes:
		ids := make([]ent.Value, 0, len(m.episodes))
		for id := range m.episodes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ComicMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedtags != nil {
		edges = append(edges, comic.EdgeTags)
	}
	if m.removedepisodes != nil {
		edges = append(edges, comic.EdgeEpisodes)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ComicMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case comic.EdgeTags:
		ids := make([]ent.Value, 0, len(m.removedtags))
		for id := range m.removedtags {
			ids = append(ids, id)
		}
		return ids
	case comic.EdgeEpisodes:
		ids := make([]ent.Value, 0, len(m.removedepisodes))
		for id := range m.removedepisodes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ComicMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedauthor {
		edges = append(edges, comic.EdgeAuthor)
	}
	if m.clearedmagazine {
		edges = append(edges, comic.EdgeMagazine)
	}
	if m.clearedtags {
		edges = append(edges, comic.EdgeTags)
	}
	if m.clearedepisodes {
		edges = append(edges, comic.EdgeEpisodes)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ComicMutation) EdgeCleared(name string) bool {
	switch name {
	case comic.EdgeAuthor:
		return m.clearedauthor
	case comic.EdgeMagazine:
		return m.clearedmagazine
	case comic.EdgeTags:
		return m.clearedtags
	case comic.EdgeEpisodes:
		return m.clearedepisodes
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ComicMutation) ClearEdge(name string) error {
	switch name {
	case comic.EdgeAuthor:
		m.ClearAuthor()
		return nil
	case comic.EdgeMagazine:
		m.ClearMagazine()
		return nil
	}
	return fmt.Errorf("unknown Comic unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ComicMutation) ResetEdge(name string) error {
	switch name {
	case comic.EdgeAuthor:
		m.ResetAuthor()
		return nil
	case comic.EdgeMagazine:
		m.ResetMagazine()
		return nil
	case comic.EdgeTags:
		m.ResetTags()
		return nil
	case comic.EdgeEpisodes:
		m.ResetEpisodes()
		return nil
	}
	return fmt.Errorf("unknown Comic edge %s", name)
}

// EpisodeMutation represents an operation that mutates the Episode nodes in the graph.
type EpisodeMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	title         *string
	url           *string
	_Thumbnail    *string
	updated_at    *time.Time
	clearedFields map[string]struct{}
	comic         *uuid.UUID
	clearedcomic  bool
	done          bool
	oldValue      func(context.Context) (*Episode, error)
	predicates    []predicate.Episode
}

var _ ent.Mutation = (*EpisodeMutation)(nil)

// episodeOption allows management of the mutation configuration using functional options.
type episodeOption func(*EpisodeMutation)

// newEpisodeMutation creates new mutation for the Episode entity.
func newEpisodeMutation(c config, op Op, opts ...episodeOption) *EpisodeMutation {
	m := &EpisodeMutation{
		config:        c,
		op:            op,
		typ:           TypeEpisode,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEpisodeID sets the ID field of the mutation.
func withEpisodeID(id uuid.UUID) episodeOption {
	return func(m *EpisodeMutation) {
		var (
			err   error
			once  sync.Once
			value *Episode
		)
		m.oldValue = func(ctx context.Context) (*Episode, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Episode.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEpisode sets the old Episode of the mutation.
func withEpisode(node *Episode) episodeOption {
	return func(m *EpisodeMutation) {
		m.oldValue = func(context.Context) (*Episode, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EpisodeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EpisodeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Episode entities.
func (m *EpisodeMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EpisodeMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EpisodeMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Episode.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTitle sets the "title" field.
func (m *EpisodeMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *EpisodeMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Episode entity.
// If the Episode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EpisodeMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *EpisodeMutation) ResetTitle() {
	m.title = nil
}

// SetURL sets the "url" field.
func (m *EpisodeMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *EpisodeMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the Episode entity.
// If the Episode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EpisodeMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL resets all changes to the "url" field.
func (m *EpisodeMutation) ResetURL() {
	m.url = nil
}

// SetThumbnail sets the "Thumbnail" field.
func (m *EpisodeMutation) SetThumbnail(s string) {
	m._Thumbnail = &s
}

// Thumbnail returns the value of the "Thumbnail" field in the mutation.
func (m *EpisodeMutation) Thumbnail() (r string, exists bool) {
	v := m._Thumbnail
	if v == nil {
		return
	}
	return *v, true
}

// OldThumbnail returns the old "Thumbnail" field's value of the Episode entity.
// If the Episode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EpisodeMutation) OldThumbnail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThumbnail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThumbnail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThumbnail: %w", err)
	}
	return oldValue.Thumbnail, nil
}

// ResetThumbnail resets all changes to the "Thumbnail" field.
func (m *EpisodeMutation) ResetThumbnail() {
	m._Thumbnail = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EpisodeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EpisodeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Episode entity.
// If the Episode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EpisodeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EpisodeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetComicID sets the "comic_id" field.
func (m *EpisodeMutation) SetComicID(u uuid.UUID) {
	m.comic = &u
}

// ComicID returns the value of the "comic_id" field in the mutation.
func (m *EpisodeMutation) ComicID() (r uuid.UUID, exists bool) {
	v := m.comic
	if v == nil {
		return
	}
	return *v, true
}

// OldComicID returns the old "comic_id" field's value of the Episode entity.
// If the Episode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EpisodeMutation) OldComicID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComicID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComicID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComicID: %w", err)
	}
	return oldValue.ComicID, nil
}

// ResetComicID resets all changes to the "comic_id" field.
func (m *EpisodeMutation) ResetComicID() {
	m.comic = nil
}

// ClearComic clears the "comic" edge to the Comic entity.
func (m *EpisodeMutation) ClearComic() {
	m.clearedcomic = true
}

// ComicCleared reports if the "comic" edge to the Comic entity was cleared.
func (m *EpisodeMutation) ComicCleared() bool {
	return m.clearedcomic
}

// ComicIDs returns the "comic" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ComicID instead. It exists only for internal usage by the builders.
func (m *EpisodeMutation) ComicIDs() (ids []uuid.UUID) {
	if id := m.comic; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetComic resets all changes to the "comic" edge.
func (m *EpisodeMutation) ResetComic() {
	m.comic = nil
	m.clearedcomic = false
}

// Where appends a list predicates to the EpisodeMutation builder.
func (m *EpisodeMutation) Where(ps ...predicate.Episode) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *EpisodeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Episode).
func (m *EpisodeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EpisodeMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.title != nil {
		fields = append(fields, episode.FieldTitle)
	}
	if m.url != nil {
		fields = append(fields, episode.FieldURL)
	}
	if m._Thumbnail != nil {
		fields = append(fields, episode.FieldThumbnail)
	}
	if m.updated_at != nil {
		fields = append(fields, episode.FieldUpdatedAt)
	}
	if m.comic != nil {
		fields = append(fields, episode.FieldComicID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EpisodeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case episode.FieldTitle:
		return m.Title()
	case episode.FieldURL:
		return m.URL()
	case episode.FieldThumbnail:
		return m.Thumbnail()
	case episode.FieldUpdatedAt:
		return m.UpdatedAt()
	case episode.FieldComicID:
		return m.ComicID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EpisodeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case episode.FieldTitle:
		return m.OldTitle(ctx)
	case episode.FieldURL:
		return m.OldURL(ctx)
	case episode.FieldThumbnail:
		return m.OldThumbnail(ctx)
	case episode.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case episode.FieldComicID:
		return m.OldComicID(ctx)
	}
	return nil, fmt.Errorf("unknown Episode field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EpisodeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case episode.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case episode.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case episode.FieldThumbnail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThumbnail(v)
		return nil
	case episode.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case episode.FieldComicID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComicID(v)
		return nil
	}
	return fmt.Errorf("unknown Episode field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EpisodeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EpisodeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EpisodeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Episode numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EpisodeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EpisodeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EpisodeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Episode nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EpisodeMutation) ResetField(name string) error {
	switch name {
	case episode.FieldTitle:
		m.ResetTitle()
		return nil
	case episode.FieldURL:
		m.ResetURL()
		return nil
	case episode.FieldThumbnail:
		m.ResetThumbnail()
		return nil
	case episode.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case episode.FieldComicID:
		m.ResetComicID()
		return nil
	}
	return fmt.Errorf("unknown Episode field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EpisodeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.comic != nil {
		edges = append(edges, episode.EdgeComic)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EpisodeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case episode.EdgeComic:
		if id := m.comic; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EpisodeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EpisodeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EpisodeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcomic {
		edges = append(edges, episode.EdgeComic)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EpisodeMutation) EdgeCleared(name string) bool {
	switch name {
	case episode.EdgeComic:
		return m.clearedcomic
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EpisodeMutation) ClearEdge(name string) error {
	switch name {
	case episode.EdgeComic:
		m.ClearComic()
		return nil
	}
	return fmt.Errorf("unknown Episode unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EpisodeMutation) ResetEdge(name string) error {
	switch name {
	case episode.EdgeComic:
		m.ResetComic()
		return nil
	}
	return fmt.Errorf("unknown Episode edge %s", name)
}

// MagazineMutation represents an operation that mutates the Magazine nodes in the graph.
type MagazineMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	name          *string
	clearedFields map[string]struct{}
	comics        map[uuid.UUID]struct{}
	removedcomics map[uuid.UUID]struct{}
	clearedcomics bool
	done          bool
	oldValue      func(context.Context) (*Magazine, error)
	predicates    []predicate.Magazine
}

var _ ent.Mutation = (*MagazineMutation)(nil)

// magazineOption allows management of the mutation configuration using functional options.
type magazineOption func(*MagazineMutation)

// newMagazineMutation creates new mutation for the Magazine entity.
func newMagazineMutation(c config, op Op, opts ...magazineOption) *MagazineMutation {
	m := &MagazineMutation{
		config:        c,
		op:            op,
		typ:           TypeMagazine,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMagazineID sets the ID field of the mutation.
func withMagazineID(id uuid.UUID) magazineOption {
	return func(m *MagazineMutation) {
		var (
			err   error
			once  sync.Once
			value *Magazine
		)
		m.oldValue = func(ctx context.Context) (*Magazine, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Magazine.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMagazine sets the old Magazine of the mutation.
func withMagazine(node *Magazine) magazineOption {
	return func(m *MagazineMutation) {
		m.oldValue = func(context.Context) (*Magazine, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MagazineMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MagazineMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Magazine entities.
func (m *MagazineMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MagazineMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MagazineMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Magazine.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *MagazineMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *MagazineMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Magazine entity.
// If the Magazine object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MagazineMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *MagazineMutation) ResetName() {
	m.name = nil
}

// AddComicIDs adds the "comics" edge to the Comic entity by ids.
func (m *MagazineMutation) AddComicIDs(ids ...uuid.UUID) {
	if m.comics == nil {
		m.comics = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.comics[ids[i]] = struct{}{}
	}
}

// ClearComics clears the "comics" edge to the Comic entity.
func (m *MagazineMutation) ClearComics() {
	m.clearedcomics = true
}

// ComicsCleared reports if the "comics" edge to the Comic entity was cleared.
func (m *MagazineMutation) ComicsCleared() bool {
	return m.clearedcomics
}

// RemoveComicIDs removes the "comics" edge to the Comic entity by IDs.
func (m *MagazineMutation) RemoveComicIDs(ids ...uuid.UUID) {
	if m.removedcomics == nil {
		m.removedcomics = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.comics, ids[i])
		m.removedcomics[ids[i]] = struct{}{}
	}
}

// RemovedComics returns the removed IDs of the "comics" edge to the Comic entity.
func (m *MagazineMutation) RemovedComicsIDs() (ids []uuid.UUID) {
	for id := range m.removedcomics {
		ids = append(ids, id)
	}
	return
}

// ComicsIDs returns the "comics" edge IDs in the mutation.
func (m *MagazineMutation) ComicsIDs() (ids []uuid.UUID) {
	for id := range m.comics {
		ids = append(ids, id)
	}
	return
}

// ResetComics resets all changes to the "comics" edge.
func (m *MagazineMutation) ResetComics() {
	m.comics = nil
	m.clearedcomics = false
	m.removedcomics = nil
}

// Where appends a list predicates to the MagazineMutation builder.
func (m *MagazineMutation) Where(ps ...predicate.Magazine) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *MagazineMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Magazine).
func (m *MagazineMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MagazineMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, magazine.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MagazineMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case magazine.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MagazineMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case magazine.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Magazine field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MagazineMutation) SetField(name string, value ent.Value) error {
	switch name {
	case magazine.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Magazine field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MagazineMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MagazineMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MagazineMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Magazine numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MagazineMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MagazineMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MagazineMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Magazine nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MagazineMutation) ResetField(name string) error {
	switch name {
	case magazine.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Magazine field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MagazineMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.comics != nil {
		edges = append(edges, magazine.EdgeComics)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MagazineMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case magazine.EdgeComics:
		ids := make([]ent.Value, 0, len(m.comics))
		for id := range m.comics {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MagazineMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedcomics != nil {
		edges = append(edges, magazine.EdgeComics)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MagazineMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case magazine.EdgeComics:
		ids := make([]ent.Value, 0, len(m.removedcomics))
		for id := range m.removedcomics {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MagazineMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcomics {
		edges = append(edges, magazine.EdgeComics)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MagazineMutation) EdgeCleared(name string) bool {
	switch name {
	case magazine.EdgeComics:
		return m.clearedcomics
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MagazineMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Magazine unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MagazineMutation) ResetEdge(name string) error {
	switch name {
	case magazine.EdgeComics:
		m.ResetComics()
		return nil
	}
	return fmt.Errorf("unknown Magazine edge %s", name)
}

// TagMutation represents an operation that mutates the Tag nodes in the graph.
type TagMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	name          *string
	clearedFields map[string]struct{}
	comics        map[uuid.UUID]struct{}
	removedcomics map[uuid.UUID]struct{}
	clearedcomics bool
	done          bool
	oldValue      func(context.Context) (*Tag, error)
	predicates    []predicate.Tag
}

var _ ent.Mutation = (*TagMutation)(nil)

// tagOption allows management of the mutation configuration using functional options.
type tagOption func(*TagMutation)

// newTagMutation creates new mutation for the Tag entity.
func newTagMutation(c config, op Op, opts ...tagOption) *TagMutation {
	m := &TagMutation{
		config:        c,
		op:            op,
		typ:           TypeTag,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTagID sets the ID field of the mutation.
func withTagID(id uuid.UUID) tagOption {
	return func(m *TagMutation) {
		var (
			err   error
			once  sync.Once
			value *Tag
		)
		m.oldValue = func(ctx context.Context) (*Tag, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Tag.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTag sets the old Tag of the mutation.
func withTag(node *Tag) tagOption {
	return func(m *TagMutation) {
		m.oldValue = func(context.Context) (*Tag, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TagMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TagMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Tag entities.
func (m *TagMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TagMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TagMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Tag.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *TagMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TagMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TagMutation) ResetName() {
	m.name = nil
}

// AddComicIDs adds the "comics" edge to the Comic entity by ids.
func (m *TagMutation) AddComicIDs(ids ...uuid.UUID) {
	if m.comics == nil {
		m.comics = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.comics[ids[i]] = struct{}{}
	}
}

// ClearComics clears the "comics" edge to the Comic entity.
func (m *TagMutation) ClearComics() {
	m.clearedcomics = true
}

// ComicsCleared reports if the "comics" edge to the Comic entity was cleared.
func (m *TagMutation) ComicsCleared() bool {
	return m.clearedcomics
}

// RemoveComicIDs removes the "comics" edge to the Comic entity by IDs.
func (m *TagMutation) RemoveComicIDs(ids ...uuid.UUID) {
	if m.removedcomics == nil {
		m.removedcomics = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.comics, ids[i])
		m.removedcomics[ids[i]] = struct{}{}
	}
}

// RemovedComics returns the removed IDs of the "comics" edge to the Comic entity.
func (m *TagMutation) RemovedComicsIDs() (ids []uuid.UUID) {
	for id := range m.removedcomics {
		ids = append(ids, id)
	}
	return
}

// ComicsIDs returns the "comics" edge IDs in the mutation.
func (m *TagMutation) ComicsIDs() (ids []uuid.UUID) {
	for id := range m.comics {
		ids = append(ids, id)
	}
	return
}

// ResetComics resets all changes to the "comics" edge.
func (m *TagMutation) ResetComics() {
	m.comics = nil
	m.clearedcomics = false
	m.removedcomics = nil
}

// Where appends a list predicates to the TagMutation builder.
func (m *TagMutation) Where(ps ...predicate.Tag) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TagMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Tag).
func (m *TagMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TagMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, tag.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TagMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tag.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TagMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tag.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Tag field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TagMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tag.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Tag field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TagMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TagMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TagMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Tag numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TagMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TagMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TagMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Tag nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TagMutation) ResetField(name string) error {
	switch name {
	case tag.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Tag field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TagMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.comics != nil {
		edges = append(edges, tag.EdgeComics)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TagMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tag.EdgeComics:
		ids := make([]ent.Value, 0, len(m.comics))
		for id := range m.comics {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TagMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedcomics != nil {
		edges = append(edges, tag.EdgeComics)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TagMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case tag.EdgeComics:
		ids := make([]ent.Value, 0, len(m.removedcomics))
		for id := range m.removedcomics {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TagMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcomics {
		edges = append(edges, tag.EdgeComics)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TagMutation) EdgeCleared(name string) bool {
	switch name {
	case tag.EdgeComics:
		return m.clearedcomics
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TagMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Tag unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TagMutation) ResetEdge(name string) error {
	switch name {
	case tag.EdgeComics:
		m.ResetComics()
		return nil
	}
	return fmt.Errorf("unknown Tag edge %s", name)
}
